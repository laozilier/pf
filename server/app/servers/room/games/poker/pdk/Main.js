/** * * 跑得快游戏 * Created by apple on 2018/1/16. */const Player = require('./Player');const Algorithm = require('./algorithm');const Event = require('./Event');const Status = require('./const').status;const Conf = require('./config');const CardsType = require('./const').cardsType;class Main extends require('../../BaseMain') {    constructor(uids, rule, room) {        super(room);        this.rule = rule;        this._algorithm = new Algorithm();        this._algorithm.setRule(rule);                this.heitao3fisrt = (rule.first == 0);      /** 黑桃三先出 */        this.stopCheatings = rule.stopCheatings;    /** 防作弊 */        this.isVisibles = rule.isVisibles;          /** 显示牌数 */        this.smallTong = rule.playTypes[4] > 0;     /** 小通 */        this.doubleQuote = rule.playTypes[5] > 0;   /** 双报 */        this.zaniao = rule.gameRules[3] > 0;        /** 扎鸟 */        /**保存玩家出的牌,经过转换的*/        this.foldsList = [];        /**底分*/        this.ante = rule.ante ? rule.ante : 100;        /** 玩家uid列表 */        this.uids = uids;        /** 庄家uid */        this.bankerUid = -1;        /** 切牌者uid */        this.qieUid = -1;        /** 是否切牌 */        this.alreayQie = false;        /** 玩家对象 */        this.players = [];        /** 当前出牌的玩家uid */        this.turn = -1;        /** 玩家当前打出的牌 */        this.setLastCards();        let cards = this._algorithm.deal(1);        // cards = [        //     37, 34, 38, 40, 19, 9, 28, 46, 17, 47, 30, 16, 7, 36, 33,        //     35, 41, 6, 48, 45, 44, 5, 23, 10, 39, 15, 43, 49, 51, 50,        //     25, 18, 20, 3, 42, 21, 24, 32, 2, 29, 22, 4, 8, 31, 11        // ];        let len = cards.length/3;        this.heitao3Uid = -1;        this.heitao3 = false;        //创建玩家        this.uids.forEach((uid, i) => {            let player = new Player(this);            player.uid = uid;            player.seatId = i;            player.isTrusteeship = room.player(uid).isTrusteeship;            player.beginHolds = cards.splice(0, len);            if (player.beginHolds.indexOf(41) > -1) {                this.heitao3Uid = uid;            }            this.players.push(player);        }, this);        /**  剩下的牌  **/        this.leftCards = cards;    }    /**     * 开始游戏     */    begin() {        /** 游戏开始 */        this.sendAll(Event.gameBegin, {uids: this.uids});        /** 确定先出 */        let wid = undefined;        let lastUids = this.getLasting().lastUids;        if (!!lastUids) {            let lastUidsStr = lastUids.sort().toString();            let curUids = this.uids.concat();            let curUidsStr = curUids.sort().toString();            if (lastUidsStr == curUidsStr) {                wid = this.getLasting().winnerUid; //上一局赢家            }        } else {            wid = this.getLasting().winnerUid; //上一局赢家        }        /** 如果能找到 */        if (!!wid && this.uids.includes(wid)) {            this.heitao3Uid = -1;            this.bankerUid = wid;            this._algorithm.heitao3fisrt = false;            this.broadcastBanker();            /** 切牌 */            this.changeStatus(Status.CUT_CARD);        } else {            /** 否则如果是3人 看看是随机还是黑桃3 即 41 */            if (this.uids.length > 2 && this.heitao3fisrt) {                this.bankerUid = this.heitao3Uid;            }            /** 随机庄 */            if (this.bankerUid < 0) {                this._algorithm.heitao3fisrt = false;                this.heitao3Uid = -1;                this.bankerUid = this.uids[Math.randomRange(0, this.uids.length)];            }            /** 直接开始 首先发牌 */            this.setTimeout(()=> {                this.sendHoldsToPlayer(true);            });        }    }    /**     * 给玩家发牌     */    sendHoldsToPlayer(need) {        this.changeStatus(Status.SENDHOLDS);        this.players.forEach(el=> {            if (!!this.stopCheatings) {                el.send(Event.holds, {holds: el.beginHolds.length, c: 1});            } else {                el.sendHolds(1);            }            if (!!this.isVisibles) {                el.canNum = true;                this.sendAll(Event.localCardNum, {uid: el.uid, num: el.beginHolds.length});            }        });        this.setTimeout(()=> {            if (!!need) {                if (this.heitao3Uid > 0) {                    this.sendAll(Event.heitao3, this.heitao3Uid);                    this.heitao3 = true;                }                this.broadcastBanker();            }            this.changeStatus(Status.DISCARD);        }, 2000);    }    /***     * 桌子状态改变     * @param code     */    changeStatus(code) {        this.log(`table change status: ${code}`);        this.status = code;        this.sendAll(Event.gameStatus, {status: code});        switch (code) {            case Status.CUT_CARD:                let bankerIdx = this.uids.indexOf(this.bankerUid);                let qieIdx = bankerIdx-1;                if (qieIdx < 0) {                    qieIdx = this.uids.length-1;                }                this.qieUid = this.uids[qieIdx];                this.log(`询问切牌 ask_cutCard this.qieUid = ${this.qieUid}`);                this.alreayQie = false;                this.sendAll(Event.ask_cutCard, this.qieUid);                this.startTimeout(this.player(this.qieUid));                break;            case Status.DISCARD:                let banker = this.uids.indexOf(this.bankerUid);                this.nextTurn(banker);                break;        }    }    broadcastBanker () {        /** 设置庄家 */        this.sendAll(Event.broadcastBanker, this.bankerUid);    }    /**     *  给前端发送切牌消息     */    cutCard(uid, index) {        if (uid != this.qieUid) {            return;        }        if (this.alreayQie) {            return;        }        this.alreayQie = true;        console.log("切牌：",index);        this.sendAll(Event.cutCard, {index: index});        //等待切牌结束        this.setTimeout(() => {            /** 直接开始 首先发牌 */            this.sendHoldsToPlayer();        });    }    /**     * 计算炸弹的分数     * @param turnPlayer  打出炸弹的玩家     */    async calculateBombScore(bombPlayer){        let scoreObj = {};        let totalScore = 0;        this.players.forEach((player) => {            if(player.uid === bombPlayer.uid){                return;            }            let score = 10 * this.ante;            totalScore += score;            scoreObj[player.uid] = score;            player.halfwayScore -= score;            bombPlayer.halfwayScore += score;        });        let winObj = {};        winObj[bombPlayer.uid] = totalScore;        //中途分数，在中途就要计算完成        let actual = await this.room.pushHalfwayScore(winObj, scoreObj);        //通知前端，炸弹计分        this.sendAll(Event.bomb_score, actual);        this.foldsList.push({event: Event.bomb_score, msg: actual});    }    /***     * 下一个玩家     */    nextTurn(seat) {        /** 先清除自动计时器 */        if (!!this._autoTimeout) {            this.clearTimeout(this._autoTimeout);            this._autoTimeout = undefined;        }        /** 轮流出牌 */        if (seat == undefined || seat == null || seat < 0) {            if (this.turn < 0) {                this.turn = Math.randomRange(0, this.uids.length);            } else {                this.turn = (this.turn + 1) % this.uids.length;            }        } else {            this.turn = seat;        }        let delay = 0;        let turnPlayer = this.players[this.turn];        if (!Array.isArray(turnPlayer.holds)) {            turnPlayer.sendHolds(2);            delay = 1000;        }        let isFirstDiscard = false;        if (!!this.lastCards) {            if (turnPlayer.uid == this.lastCards.uid) {                if (this.lastCards.type === CardsType.AAAA) {                    this.calculateBombScore(turnPlayer);                }                this.setLastCards();                /** 如果能作为一手牌出完的时候不用考虑下家是否报单 */                let cardsData = this._algorithm.checkCanOut(turnPlayer.holds, [].concat(turnPlayer.holds));                if (!!cardsData && cardsData.type != CardsType.AAAABB && cardsData.type != CardsType.AAAABBB) {                    this.setTimeout(()=> {                        this.discard(turnPlayer, cardsData.cards);                    });                    return;                }                cardsData = this._algorithm.findAutoCards(turnPlayer.holds);                turnPlayer.autoCards = cardsData.cards;                isFirstDiscard = true;            } else {                let cardsData = this._algorithm.findAutoBigCards(turnPlayer.holds);                if (!!cardsData) {                    if (cardsData.cards.length == turnPlayer.holds.length) {                        this.setTimeout(()=> {                            this.discard(turnPlayer, cardsData.cards);                        });                        return;                    }                    turnPlayer.autoCards = cardsData.cards;                } else {                    this.setTimeout(()=> {                        let msg = {uid: turnPlayer.uid};                        turnPlayer.sendAll(Event.pass, msg);                        this.foldsList.push({event: Event.pass, msg: msg});                        this.nextTurn();                    });                    return;                }            }        } else {            /** 如果能作为一手牌出完的时候不用考虑下家是否报单 */            let cardsData = this._algorithm.checkCanOut(turnPlayer.holds, [].concat(turnPlayer.holds));            if (!!cardsData && cardsData.type != CardsType.AAAABB && cardsData.type != CardsType.AAAABBB) {                this.setTimeout(()=> {                    this.discard(turnPlayer, cardsData.cards);                });                return;            }            cardsData = this._algorithm.findAutoCards(turnPlayer.holds);            turnPlayer.autoCards = cardsData.cards;            isFirstDiscard = true;        }        this.setTimeout(()=> {            this.sendAll(Event.turn, {turn: turnPlayer.uid, isFirstDiscard: isFirstDiscard});            this.startTimeout(turnPlayer);        }, delay);    }    setLastCards(data) {        this.lastCards = data;        this._algorithm.lastCards = data;    }    /**     * 获取下一个位置的玩家     * @param p     * @returns {*}     */    getNextPlayer(p) {        let idx = this.uids.indexOf(p.uid);        idx+=1;        if (idx >= this.uids.length) {            idx = 0;        }        return this.players[idx];    }    /**     * 玩家主动托管     * @param player     */    checkPlayerIsTrusteeship(player) {        if (player.seatId != this.turn) {            return;        }        if (player.isTrusteeship) {            this.startTimeout(player, true);        } else {            /** 开启自动计时器 */            this.startTimeout(player);        }    }    /**     * 玩家自动托管     */    playerAutoTrusteeship(player) {        if (!player.isTrusteeship) {            player.isTrusteeship = true;            this.room.player(player.uid).isTrusteeship = true;            this.sendAll(Event.tuoGuang, [player.uid, player.isTrusteeship]);        }    }    /**     * 启动托管计时器     * @param turnPlayer     */    startTimeout (turnPlayer, quick) {        // return;        /** 先清除自动计时器 */        if (!!this._autoTimeout) {            this.clearTimeout(this._autoTimeout);            this._autoTimeout = undefined;        }        switch (this.status) {            case Status.CUT_CARD:                this._autoTimeout = this.setTimeout(() => {                    turnPlayer.cutCard(Math.randomRange(8, 36));                }, Conf.qiepaiTime);                break;            case Status.DISCARD:                let actionTime = Conf.actionTime;                if (!!turnPlayer) {} else {                    turnPlayer = this.player(this.bankerUid);                }                if (!!turnPlayer && turnPlayer.isTrusteeship) {                    actionTime = !!quick ? 0 : 1000;                }                this._autoTimeout = this.setTimeout(() => {                    this.discard(turnPlayer, turnPlayer.autoCards);                    this.playerAutoTrusteeship(turnPlayer);                }, actionTime);                break;            default:                break;        }    }    /**     * 出牌     * @param turnPlayer     * @param cards     */    discard(turnPlayer, cards) {        this.log(`出牌 lastCards = ${JSON.stringify(this.lastCards)}`);        this.log(`出牌 cards = ${cards}`);        this.log(`出牌 turnPlayer.holds = ${turnPlayer.holds}`);        if (this.turn !== turnPlayer.seatId) {            this.send(turnPlayer.uid, Event.toast, '轮转错误!');            return false;        }        if (!Array.isArray(cards) || cards.length == 0) {            return false;        }        let nextPlayer = this.getNextPlayer(turnPlayer);        let cardsData = this._algorithm.checkCanOut(turnPlayer.holds, cards, nextPlayer.alert);        this.log(`出牌 player: ${turnPlayer.uid} cardsData = ${JSON.stringify(cardsData)}`);        if (!cardsData) {            this.log("牌型不合法!");            this.send(turnPlayer.uid, Event.toast, '牌型不合法!');            return false;        }        cardsData.first = !(!!this.lastCards);        cardsData.uid = turnPlayer.uid;        turnPlayer.removeHolds(cards);        turnPlayer.autoCards = undefined;        this.heitao3 = false;        cardsData.h_len = turnPlayer.holds.length;        this.setLastCards(cardsData);        this.sendAll(Event.discard, cardsData);        this.foldsList.push({event: Event.discard, msg: cardsData});        if (!!this.isVisibles) {            this.sendAll(Event.localCardNum, {uid: turnPlayer.uid, num: turnPlayer.holds.length});        }        if (turnPlayer.holds.length == 0) {            this.setTimeout(()=> {                this.calculateResult(turnPlayer);            });        } else {            this.nextTurn();        }    }    /**     * 计算结果     * @param winPlayer     */    async calculateResult(winPlayer) {        if (this._gameEnd) {            return;        }        this._gameEnd = true;        //计算玩家得分        this.calScore(winPlayer);        //记录这一局赢家，方便下一局使用        this.getLasting().winnerUid = winPlayer.uid;        this.getLasting().lastUids = this.uids.concat();        let loserCard = {}; //剩下的牌        this.players.forEach(el => {            let holds = Array.isArray(el.holds) ? el.holds : el.beginHolds;            if (holds.length > 0) {                loserCard[el.uid] = holds;            }        });        //上传分数        let actualScores = await this.pushScore();        this.sendAll(Event.gameResult, {            allScore: actualScores,            loserCard: loserCard,            leftCards: this.leftCards        });        this.setTimeout(() => {            this.end();        }, 1000);    }    /**     * 计算结果得分     * @param winPlayer     */    calScore(winPlayer){        let alertCount = 0;        this.players.forEach((player) => {            let cardsNumber = 0;            if (Array.isArray(player.holds)) {                cardsNumber = player.holds.length;            } else {                cardsNumber = player.beginHolds.length;            }            //赢家不计算            if(player.uid === winPlayer.uid) return;            //报单不计算            if(cardsNumber === 1) return ++alertCount;            //剩余牌            if (cardsNumber === player.beginHolds.length) { //春天                cardsNumber *= 2;            } else if(this.smallTong && cardsNumber >= 10) { //小通                cardsNumber = player.beginHolds.length;            }            //判断是否扎鸟            if (this.zaniao) {                if (player.beginHolds.includes(35) || winPlayer.beginHolds.includes(35)) {                    cardsNumber *= 2;                }            }            //计算分数            let score = cardsNumber * this.ante; //计算分数            player.score -= score;            winPlayer.score += score;        });        //双报        if (alertCount === 2 && this.doubleQuote) {            this.players.forEach((player) => {                if(player.uid === winPlayer.uid) return;                let cardsNumber = 5;                //判断是否扎鸟                if (this.zaniao) {                    if (player.beginHolds.includes(35) || winPlayer.beginHolds.includes(35)) {                        cardsNumber *= 2;                    }                }                //计算分数                let score = cardsNumber * this.ante; //计算分数                player.score -= score;                winPlayer.score += score;            });        }    }    /**     * 回放数据     */    getPlayback() {        let history = {            uids: this.uids,            foldsList: this.foldsList,            banker: this.bankerUid,            leftCards:this.leftCards        };        this.players.forEach((player, index) => {            history[player.uid] = {                holds: player.beginHolds            };        });        return history;    }    /**     * 获取游戏信息     */    getInfo(uid) {        uid = parseInt(uid);        let msg = {            uids: this.uids,                        //当前游戏中的玩家            turn: this.uids[this.turn],            status: this.status,            banker: this.bankerUid,            qieUid: this.qieUid,            alreayQie: this.alreayQie,            lastCards: this.lastCards,            operatTime: this.operatTime,            heitao3: this.heitao3,            players: {},        };        this.players.forEach(function (el) {            if (uid === el.uid) {                msg.players[el.uid] = el.getInfos();            } else {                msg.players[el.uid] = el.getOtherInfos();            }        }, this);        this.send(uid, Event.gameInfo, msg);    }    log(info) {        // console.log(`table[${this.room.rid}] info：`, info);    }}module.exports = Main;