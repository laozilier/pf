/** * Created by T-Vick on 2017/9/29. *//** * 三公牌型 * @type {{BI_SHI: number, YI_DIAN: number, LIANG_DIAN: number, SAN_DIAN: number, SI_DIAN: number, WU_DIAN: number, LIU_DIAN: number, QI_DIAN: number, BA_DIAN: number, JIU_DIAN: number, SAN_GONG: number, SAN_TIAO: number, BAO_SAN: number}} */let Pattern3 = {    BI_SHI: 0, // 弊十（零点）    YI_DIAN: 1,    LIANG_DIAN: 2,    SAN_DIAN: 3,    SI_DIAN: 4,    WU_DIAN: 5,    LIU_DIAN: 6,    QI_DIAN: 7,    BA_DIAN: 8,    JIU_DIAN: 9,    SAN_GONG: 10,    SAN_TIAO: 11,    BAO_SAN: 12};/** * 金花牌型 * @type {{WU_LONG: number, DUI_ZI: number, SHUN_ZI: number, JIN_HUA: number, JIN_HUA_SHUN: number, BAO_ZI: number}} */let PatternJH = {    WU_LONG: 0, // 乌龙(散牌)    DUI_ZI: 1,    SHUN_ZI: 2,    JIN_HUA: 3,    JIN_HUA_SHUN: 4,    BAO_ZI: 5};let pokers = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];exports.getPokers = function (algRule) {    let _pokers = pokers.concat();    _pokers.forEach(function (n, i) {        let ii = parseInt(Math.random() * _pokers.length);        _pokers[i] = _pokers[ii];        _pokers[ii] = n;    });    return _pokers;};/** * 获取单张牌的牌值 * @param card * @param isAlargest * @returns {number} */function val(card, isAlargest) {    // todo: 根据选项判断牌是在三公中的值还是在金花中的值    let value = card % 13;    if (card == 52) {        return 16;    } else if (card == 53) {        return 17;    } else if (isAlargest) {        let i = [0].indexOf(value);        if (i > -1) {            return 13 + i + 1;        }    }    return (value + 1);}/** * 获取牌的花色 * 0.方片；1.梅花；2.红桃；3.黑桃 * @param card * @return {number} 类型  0.方片；1.梅花；2.红桃；3.黑桃 */function getColor(card) {    if ([52, 53].indexOf(card) > -1) {        return 4;    }    return Math.floor(card / 13);}/** * 两张牌是否相连 * @return {boolean} 如果相连返回true */function isContinuous(max, min) {    // todo: 2连不连（连队和顺子）    if ([15, 16, 17].indexOf(max) > -1 || [15, 16, 17].indexOf(min) > -1) {        return false;    }    if (max - min === 1) {        return true;    }}/** * 查找数量相同，且连续的值 * @param cardsMap * @param continueCount * @returns {Array} */function findContinueVals(cardsMap, continueCount) {    let continueList = [];    for (let i = 0; i < cardsMap.sortedValsDesc.length - 1; i++) {        let v = cardsMap.sortedValsDesc[i];        if (cardsMap.valCardsMap[v].length < continueCount) {            continue;        }        let lianVal = [v];        for (let j = i + 1; j < cardsMap.sortedValsDesc.length; j++) {            let nextV = cardsMap.sortedValsDesc[j];            if (cardsMap.valCardsMap[nextV].length < continueCount) {                break;            }            let curV = lianVal[0];            if (isContinuous(curV, nextV)) {                lianVal.unshift(nextV);            } else {                break;            }        }        if (lianVal.length > 1) {            continueList.unshift(lianVal);            i += lianVal.length - 1;        }    }    return continueList;}/** * 获取值牌映射 * @param cards * @returns {{cards: Array, valCardsMap, sortedVals: number[]}} */function getCardsMap(cards, isAlargest) {    //记录每张牌的数量    let valCardsMap = {};    let tempCards = [];    cards.forEach(el => {        let v = val(el, isAlargest);        if (valCardsMap[v]) {            valCardsMap[v].push(el);        } else {            valCardsMap[v] = [el];        }    });    for (let val in valCardsMap) {        valCardsMap[val].sort(function (a, b) {            return b - a        });    }    let sortedVals = Object.keys(valCardsMap).map(function (val) {        return parseInt(val)    });    for (let i = 0; i < sortedVals.length - 1; i++) {        for (let j = i + 1; j < sortedVals.length; j++) {            // 数量多的考前            if (valCardsMap[sortedVals[j]].length > valCardsMap[sortedVals[i]].length) {                let temp = sortedVals[i];                sortedVals[i] = sortedVals[j];                sortedVals[j] = temp;            }            // 数量相同的牌值大的靠前            if (valCardsMap[sortedVals[j]].length == valCardsMap[sortedVals[i]].length) {                if (sortedVals[j] > sortedVals[i]) {                    let temp = sortedVals[i];                    sortedVals[i] = sortedVals[j];                    sortedVals[j] = temp;                }            }        }    }    let sortedValsDesc = sortedVals.concat();    for (let i = 0; i < sortedValsDesc.length - 1; i++) {        for (let j = i + 1; j < sortedValsDesc.length; j++) {            if (sortedValsDesc[j] > sortedValsDesc[i]) {                let temp = sortedValsDesc[i];                sortedValsDesc[i] = sortedValsDesc[j];                sortedValsDesc[j] = temp;            }        }    }    for (let val of sortedVals) {        tempCards = tempCards.concat(valCardsMap[val]);    }    // console.log(valCardsMap,  sortedVals);    return {cards: tempCards, valCardsMap, sortedVals, sortedValsDesc};}/** * 获取花色与牌的映射 * @param cards * @returns {{cards: Array, colorCardsMap, sortedColors: number[]}} */function getColorMap(cards) {    //记录每张牌的数量    let colorCardsMap = {};    let tempCards = [];    cards.forEach(c => {        let color = getColor(c);        if (colorCardsMap[color]) {            colorCardsMap[color].push(c);        } else {            colorCardsMap[color] = [c];        }    });    // for (let color in colorCardsMap) {    //     colorCardsMap[color].sort(function(a, b) {return b - a});    // }    let sortedColors = Object.keys(colorCardsMap).map(function (color) {        return parseInt(color)    });    for (let i = 0; i < sortedColors.length - 1; i++) {        for (let j = i + 1; j < sortedColors.length; j++) {            // 数量多的考前            if (colorCardsMap[sortedColors[j]].length > colorCardsMap[sortedColors[i]].length) {                let temp = sortedColors[i];                sortedColors[i] = sortedColors[j];                sortedColors[j] = temp;            }            // 数量相同的牌值大的靠前            if (colorCardsMap[sortedColors[j]].length == colorCardsMap[sortedColors[i]].length) {                if (sortedColors[j] > sortedColors[i]) {                    let temp = sortedColors[i];                    sortedColors[i] = sortedColors[j];                    sortedColors[j] = temp;                }            }        }    }    for (let val of sortedColors) {        tempCards = tempCards.concat(colorCardsMap[val]);    }    // console.log(colorCardsMap,  sortedColors);    return {cards: tempCards, colorCardsMap, sortedColors};}/** * 获取一首牌的值 * @param cardsMap * @param pattern * @returns {number} */function getPatternValue(cardsMap, pattern) {    let maxCardVal = [cardsMap.sortedValsDesc[0]];    let maxCard = cardsMap.valCardsMap[maxCardVal][0];    let maxCardColor = getColor(maxCard);    let valStr = '0x' + Number(maxCardVal).toString(16) + maxCardColor.toString(16);    return parseInt(valStr) + pattern * 10000;}/** * 获取一首牌的值 * @param cardsMap * @param pattern * @returns {number} */function getPatternJhValue(cardsMap, pattern) {    let valStr = '0x';    switch (pattern) {        case PatternJH.BAO_ZI:        case PatternJH.DUI_ZI:            for (let v of cardsMap.sortedVals) {                let cs = cardsMap.valCardsMap[v];                for (let c of cs) {                    valStr += val(c, true).toString(16);                }            }            break;        case PatternJH.JIN_HUA_SHUN:        case PatternJH.JIN_HUA:        case PatternJH.SHUN_ZI:        case PatternJH.WU_LONG:            for (let v of cardsMap.sortedValsDesc) {                let cs = cardsMap.valCardsMap[v];                for (let c of cs) {                    valStr += val(c, true).toString(16);                }            }            break;        default:            return 0;    }    return parseInt(valStr) + pattern * 10000;}/** * 寻找顺子 * @param cardsMap * @param length * @returns {*} */function findABC(cardsMap, length) {    cardsMap = JSON.parse(JSON.stringify(cardsMap));    // todo: 金花的A23算不算顺子    if (cardsMap.valCardsMap[14]) {        cardsMap.valCardsMap[1] = cardsMap.valCardsMap[14];        cardsMap.sortedValsDesc.push(1);    }    let continueList = findContinueVals(cardsMap, 1);    if (!Array.isArray(continueList) || !continueList.length) {        return;    }    // list中的值是从小到大排序的    let list = null;    for (let lianVal of continueList) {        if (lianVal.length >= length) {            list = lianVal;            break;        }    }    if (!list) {        return;    }    let shunZi = [];    // 优先取最大的顺子    for (let i = list.length - 1; i > -1; i--) {        let v = list[i];        shunZi.unshift(cardsMap.valCardsMap[v][0]); // 直接从黑桃先去        if (shunZi.length == length) {            break;        }    }    return shunZi;}/** * 检查顺子牌型 * @param cards * @returns {{cards: Array, pattern: number, value: *, multi: number}} */function checkPattern3(cards) {    let cardsMap = getCardsMap(cards, false);    let maxCount = cardsMap.valCardsMap[cardsMap.sortedVals[0]].length;    // 爆三、三条    if (maxCount == 3) {        if (cardsMap.sortedVals[0] == 3) {            return {                cards: cards,                pattern: Pattern3.BAO_SAN,                value: getPatternValue(cardsMap, Pattern3.BAO_SAN),                multi: 9            };        }        return {            cards: cards,            pattern: Pattern3.SAN_TIAO,            value: getPatternValue(cardsMap, Pattern3.SAN_TIAO),            multi: 5        }    }    let minVal = cardsMap.sortedValsDesc[cardsMap.sortedValsDesc.length - 1];    let maxVal = cardsMap.sortedValsDesc[0];    if (minVal > 10 && maxVal < 14) {        return {            cards: cards,            pattern: Pattern3.SAN_GONG,            value: getPatternValue(cardsMap, Pattern3.SAN_GONG),            multi: 4        }    }        let pattern = 0;    for (let v of cardsMap.sortedValsDesc) {        let numCards = cardsMap.valCardsMap[v].length;        pattern += (v > 9 ? 0 : v) * numCards;    }    pattern %= 10;    let m = 1;    if (pattern == 9) {        m = 3;    } else if (pattern == 8) {        m = 2;    }    return {        cards: cards,        pattern: pattern,        value: getPatternValue(cardsMap, pattern),        multi: m    }}// 检查金花牌型function checkPatternJH(cards) {    let cardsMap = getCardsMap(cards, true);    let colorMap = getColorMap(cards);    let maxCount = cardsMap.valCardsMap[cardsMap.sortedVals[0]].length;    let maxColor = colorMap.colorCardsMap[colorMap.sortedColors[0]].length;    // 豹子    if (maxCount == 3) {        return {            cards: cards,            pattern: PatternJH.BAO_ZI,            value: getPatternJhValue(cardsMap, PatternJH.BAO_ZI),            multi: 6        };    }    let shunZi = findABC(cardsMap, 3);    if (shunZi) {        // 金华顺        if (maxColor == 3) {            return {                cards: cards,                pattern: PatternJH.JIN_HUA_SHUN,                value: getPatternJhValue(cardsMap, PatternJH.JIN_HUA_SHUN),                multi: 5            };        }        // 顺子        return {            cards: cards,            pattern: PatternJH.SHUN_ZI,            value: getPatternJhValue(cardsMap, PatternJH.SHUN_ZI),            multi: 3        };    }    // 金花    if (maxColor == 3) {        return {            cards: cards,            pattern: PatternJH.JIN_HUA,            value: getPatternJhValue(cardsMap, PatternJH.JIN_HUA),            multi: 4        };    }    // 对子    if (maxCount == 2) {        return {            cards: cards,            pattern: PatternJH.DUI_ZI,            value: getPatternJhValue(cardsMap, PatternJH.DUI_ZI),            multi: 2        };    }    // 乌龙    return {        cards: cards,        pattern: PatternJH.WU_LONG,        value: getPatternJhValue(cardsMap, PatternJH.WU_LONG),        multi: 1    };}/** * 发牌 * @param count 发几手牌 * @param rule  牛牛规则 * @param {Array} [cards]  一副牌 * @return {Object} */exports.deal = function(count, rule, cards) {    //保存实际要发到玩家手上的牌    // let holds = [];    let holdsList = [];    let max = 10;    //发十手牌到这个数组，会从中间抽掉多余的牌    let allHolds = [[], [], [], [], [], [], [], [], [], []];    //下一副牌    let nextCards = [];    if(!cards){  //如果没有一副牌，则创建一手牌        cards = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];        //洗乱牌        for(let i = 0; i < cards.length; ++i){            let n = cards[i];            let ii = parseInt(Math.random() * cards.length);            cards[i] = cards[ii];            cards[ii] = n;        }    } else { //随机打乱十次        for (let i = 0; i < 10; ++i){            let i = parseInt(Math.random() * cards.length);            let j = parseInt(Math.random() * cards.length);            let n = cards[i];            cards[i] = cards[j];            cards[j] = n;        }    }    //发牌    for(let i = 0; i < cards.length; ++i){        if(i < max * 3){            let seat = i%max;            allHolds[seat].push(cards[i]);        }        nextCards.push(cards[i]);    }    //抽掉多余的牌    for (let i = 0; i < count; ++i){        let randomId = Math.randomRange(0, allHolds.length);        // let hold = allHolds.splice(randomId, 1)[0];        let holds = allHolds.splice(randomId, 1)[0];        holdsList.push(holds);    }    //[21,50,28]    //[46,47,36]    //计算结果    //holdsList = [[51,1,14], [38,24,7]];    for(let i = 0; i < count; ++i){        let holds = holdsList[i];        // todo: 计算每首牌的结果        let final = {cards: holds, sg: checkPattern3(holds)};        if (rule.playMode == 1) {            final.jh = checkPatternJH(holds);        }        holdsList[i] = final;    }    holdsList.sort((a, b) => {        if (!!a.jh && !!b.jh) {            return (b.sg.value+b.jh.value) - (a.sg.value+a.jh.value);        } else {            return b.sg.value - a.sg.value;        }    });    return {        holds: holdsList,        cards: nextCards    };};