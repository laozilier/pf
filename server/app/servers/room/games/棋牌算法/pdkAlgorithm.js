/** * Created by apple on 2018/1/22. */let pokers = [    //16张模式的一副牌    [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51],    //15张模式的一副牌    [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]];var PdkActType = {    none: 0,    //没有    danzhang: 1,//單張    duizi: 2,   //對子    sandai: 3,  //三帶    zhadan: 4,  //炸彈    liandui: 5, //連對    shunzi: 6,  //順子    sidaier: 7,     //四带二    feiji: 8,       //飛機    sidaisan: 9,    //四带三};/** * 获取牌的面值 * A=1 * J=11 * Q=12 * K=13 * @param card * @return {number}  返回牌的面值； 1,2,3,4,5,6,7,8,9,10,11,12,13 */function val(card) {    return (card%13 + 1);}/** * 获取牌的类型 * 0.方片；1.梅花；2.红桃；3.黑桃 * @param card * @return {number} 类型  0.方片；1.梅花；2.红桃；3.黑桃 */function type(card) {    return parseInt(card/13);}/** * 把牌的值转换成跑得快大小的值 * @param v  需要转换的值 * @param  t  是否需要转换成扑克牌面值 * @return {number}  返回跑得快的牌的权值，3 - 15 */function transform(v, t) {    if(t){        v = val(v);    }    if(parseInt(v) === 1){        return 14;    } else if(parseInt(v) === 2)        return 16;    else        return parseInt(v);}/** * 比较单张牌大小 * 必须是扑克面值 * 在>右则true */function comparePoker(left, right, t) {    return transform(left, t) > transform(right, t);}/** * 两张牌是否相连 * @return {boolean} 如果相连返回true */function isContinuous(min, max, t) {    if(transform(min, t) - transform(max, t) === -1){        return true;    }}/** * 排序,升序 * 必须为扑克面值 * @param cards * @param  t 是否需要转换成扑克面值 */function sort(cards, t) {    cards.sort((a, b) => {        return transform(a, t)-transform(b, t);    });    return cards;}/** * 判断数组是否为顺子 * true = 顺子 反子不是 * @param cards */function isStraight(cards, t) {    for(let i = 0; i < cards.length - 1; ++i){        if(!isContinuous(cards[i], cards[i + 1], t)){            return false;        }    }    return true;}/** * 找到最长的顺子 * @param cards 手牌 * @param t     是否需要转换 */function findMaxStraight(cards, t) {    let straight = [];    let temp = [];    for(let i = 0; i < cards.length - 1; ++i){        if(isContinuous(cards[i], cards[i + 1], t)){            temp.push(cards[i]);        } else {            temp.push(cards[i]);            if(straight.length < temp.length){                straight = temp;            }            temp = [];        }    }    temp.push(cards[cards.length - 1]);    if(straight.length > temp.length){        if(straight.length !== 1)            return straight;    }    if(temp.length !== 1){        return temp;    }}/*** * 查找数组中有多少张5 */function findPokers(cards, value, count){    let array = [];    for(let i = 0; i < cards.length; ++i){        if(val(cards[i]) === parseInt(value)){           array.push(cards[i]);        }        if(array.length === count){            return array;        }    }    return array;}//删除数组中指定数量指定的牌，function delPokers(cards, value, count){    let temp = cards.slice(0);    let array = [value - 1, 13 + value - 1, 26 + value - 1, 39 + value - 1];    for(let i = 0; i < array.length; ++i){        let el = array[i];        let index = temp.indexOf(el);        if(index > -1){            temp.splice(index, 1);            count --;        }        if(count === 0){            break;        }    }    return temp;}module.exports = {    findMaxStraight: findMaxStraight,    val: val,    transform: transform,    sort: sort,    /**     * 获取一副扑克牌     * @param type true 16张模式     */    getPokers: function (type) {        let _pokers = pokers[type ? 0 : 1];        //洗乱牌        _pokers.forEach(function (n, i) {            let ii = parseInt(Math.random() * _pokers.length);            _pokers[i] = _pokers[ii];            _pokers[ii] = n;        });        return _pokers;    },    //找到单张    getType1: function (typeObj, cards, counts){        let keys = Object.keys(counts);        keys = sort(keys);        for(let i = 0; i < keys.length; ++i){            let key = keys[i]; //牌值            let num = counts[key]; //牌数量            if(num === 4){                continue;            }            if(comparePoker(parseInt(key), typeObj.val)){                return findPokers(cards, parseInt(key), 1);            }        }        return [];    },    //找到对子    getType2: function (typeObj, cards, counts) {        let keys = Object.keys(counts);        keys = sort(keys);        for(let i = 0; i < keys.length; ++i){            let key = keys[i];            let num = counts[key]; //牌数量            if(num === 4){                continue;            }            if(num >= 2 && comparePoker(key, typeObj.val)){                return findPokers(cards, parseInt(key), 2);            }        }        return [];    },    /**     * 查找三张     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    getType3: function (typeObj, cards, counts) {        let sanzhang = [];        let keys = Object.keys(counts);        let tempKey = -1;        keys = sort(keys);        for(let i = 0; i < keys.length; ++i){            let key = keys[i];            let num = counts[key]; //牌数量            if(num === 4){                continue;            }            if(num >= 3 && comparePoker(key, typeObj.val)){                sanzhang = findPokers(cards, parseInt(key), 3);                tempKey = parseInt(key);                break;            }        }        if(sanzhang.length !== 0){            let tempCards = cards.slice(0);            tempCards = delPokers(tempCards, tempKey, 3); //删除被选中的三张牌            tempCards = sort(tempCards, true);            for(let i = 0; i < tempCards.length && i < 2; ++i){                let val = this.val(tempCards[i]);                let num = counts[val];                if(num === 4){                    continue;                }                sanzhang.push(tempCards[i]);            }        }        //三带二必须为5张        if(sanzhang.length !== 5){            return [];        }        return sanzhang;    },    //获取炸弹    getType4: function (typeObj, cards, counts) {        for(let key in counts){            if(counts[key] === 4 && comparePoker(key, typeObj.val)){                return findPokers(cards, parseInt(key), 4);            }        }        return [];    },    //获取连对    getType5: function (typeObj, cards, counts) {        let keys = Object.keys(counts);        let min = typeObj.min;        let length = typeObj.length;        let count = 1;        let index = -1;        sort(keys);        for(let i = 0; i < keys.length - 1; ++i){            let num = counts[keys[i]]; //牌数量            if(comparePoker(keys[i], min)){                if(num === 4){                    count = 1;                } else if(isContinuous(keys[i], keys[i + 1]) && counts[keys[i + 1]] >= 2 && counts[keys[i]] >= 2){                    count ++;                } else {                    count = 1;                }                if(count >= length){                    index = i + 1;                    break;                }            }        }        let result = [];        for(let i = index - length + 1;  i <= index; ++i){            let value = parseInt(keys[i]);            result = result.concat(findPokers(cards, value, 2));        }        return result;    },    //获取顺子    getType6: function (typeObj, cards, counts) {        let keys = Object.keys(counts);        let min = typeObj.min;        let length = typeObj.length;        let count = 1;        let index = -1;        sort(keys);        for(let i = 0; i < keys.length - 1; ++i){            let num = counts[keys[i]];            if(comparePoker(keys[i], min)){                if(num === 4){                    count = 1;                } else if(isContinuous(keys[i], keys[i + 1])){                    count ++;                } else {                    count = 1;                }                if(count >= length){                    index = i + 1;                    break;                }            }        }        let result = [];        for(let i = index - length + 1;  i <= index; ++i){            let value = parseInt(keys[i]);            result = result.concat(findPokers(cards, value, 1));        }        return result;    },    //四带三    getType7: function (typeObj, cards, counts) {        let tempCards = cards.slice(0);        let result = [];        let value = -1;        for(let key in counts){            if(counts[key] === 4 && comparePoker(key, typeObj.val)){                result = findPokers(cards, key, 4);                value = parseInt(key);                break;            }        }        if(result.length === 0){            return [];        }        //删除四张扑克        tempCards = delPokers(cards, value, 4);        tempCards = sort(tempCards, true); //排序        for(let i = 0; i < tempCards.length, i<3; ++i){            result.push(tempCards[0]);        }        if(result.length !== 7){            return [];        }        return result;    },    //获取一个飞机    getType8: function (typeObj, cards, counts) {        let keys = Object.keys(counts);        let min = typeObj.min;        let length = typeObj.length;        let count = 1;        let index = -1;        sort(keys);        for(let i = 0; i < keys.length - 1; ++i){            if(comparePoker(keys[i], min)){                if(isContinuous(keys[i], keys[i + 1]) && counts[keys[i + 1]] >= 3 && counts[keys[i]] >= 3){                    count ++;                } else {                    count = 1;                }                if(count >= length){                    index = i + 1;                    break;                }            }        }        if(count < length){            return [];        }        let result = [];        let tempCards = cards.slice();        for(let i = index - length + 1;  i <= index; ++i){            let value = parseInt(keys[i]);            result = result.concat(findPokers(tempCards, value, 3));            tempCards = delPokers(tempCards, value, 3);        }        for(let i = 0;i  < tempCards.length, i < length * 2; ++i){            result.push(tempCards[i]);        }        if(result.length !== length * 5){            return [];        }        return result;    },    //四带二    getType9: function (typeObj, cards, counts) {        let tempCards = cards.slice(0);        let result = [];        let value = -1;        for(let key in counts){            if(counts[key] === 4 && comparePoker(key, typeObj.val)){                result = findPokers(cards, key, 4);                value = parseInt(key);                break;            }        }        if(result.length === 0){            return [];        }        //删除四张扑克        tempCards = delPokers(cards, value, 4);        tempCards = sort(tempCards, true); //排序        for(let i = 0; i < tempCards.length, i<2; ++i){            result.push(tempCards[0]);        }        if(result.length !== 6){            return [];        }        return result;    },    /**     * 找到单张并且比较     * @param typeObj 现有的类型     * @param cards   整手牌     * @param counts  牌的数量     * @return {boolean} 如果找到返回true     */    findType1: function (typeObj, cards, counts) {        for(let key in counts){            if(comparePoker(parseInt(key), typeObj.val)){                return true;            }        }    },    /**     * 查找对子     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    findType2: function (typeObj, cards, counts) {        for(let key in counts){            if(counts[key] >= 2 && comparePoker(key, typeObj.val)){                return true;            }        }    },    /**     * 查找三张     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    findType3: function (typeObj, cards, counts) {        for(let key in counts){            if(counts[key] >= 3 && comparePoker(key, typeObj.val)){                return true;            }        }    },    /**     * 查找炸弹     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    findType4: function (typeObj, cards, counts) {        for(let key in counts){            if(counts[key] === 4 && comparePoker(key, typeObj.val)){                return true;            }        }    },    /**     * 查找连对     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    findType5: function (typeObj, cards, counts) {        let keys = Object.keys(counts);        let min = typeObj.min;        let length = typeObj.length;        let count = 1;        sort(keys);        // console.log(typeObj, cards, counts);        for(let i = 0; i < keys.length - 1; ++i){            if(comparePoker(keys[i], min)){                if(isContinuous(keys[i], keys[i + 1]) && counts[keys[i + 1]] >= 2 && counts[keys[i]] >= 2){                    count ++;                } else if(count >= length){                    console.log(keys[i]);                    return true;                } else {                    count = 1;                }            }        }        if(count >= length){            return true;        }    },    /**     * 查找顺子     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    findType6: function (typeObj, cards, counts) {        let keys = Object.keys(counts);        let min = typeObj.min;        let length = typeObj.length;        let count = 1;        sort(keys);        for(let i = 0; i < keys.length - 1; ++i){            if(comparePoker(keys[i], min)){                if(isContinuous(keys[i], keys[i + 1])){                    count ++;                } else if(count >= length){                    return true;                } else {                    count = 1;                }            }        }        if(count >= length){            return true;        }    },    /**     * 查找四带二     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    findType7: function (typeObj, cards, counts) {        for(let key in counts){            if(counts[key] === 4 && comparePoker(key, typeObj.val)){                return true;            }        }    },    /**     * 查找飞机     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    findType8: function (typeObj, cards, counts) {        let keys = Object.keys(counts);        let min = typeObj.min;        let length = typeObj.length;        let count = 1;        sort(keys);        for(let i = 0; i < keys.length - 1; ++i){            if(comparePoker(keys[i], min)){                if(isContinuous(keys[i], keys[i + 1]) && counts[keys[i + 1]] >= 3 && counts[keys[i]] >= 3){                    count ++;                } else if(count >= length){                    return true;                } else {                    count = 1;                }            }        }        if(count >= length){            return true;        }    },    /**     * 查找四带三     * @param typeObj     * @param cards     * @param counts     * @return {boolean}     */    findType9: function (typeObj, cards, counts) {        for(let key in counts){            if(counts[key] === 4 && comparePoker(key, typeObj.val)){                return true;            }        }    },    /**     *  查找牌的类型     *  1: 单张     *  2: 对子     *  3: 三张     *  4: 炸弹     *  5: 连对     *  6: 顺子     *  7: 四带二     *  8: 飞机     *  9: 四带三     * @param cards     * @return {{type: number, cards: *}}     */    parseType: function (cards) {        let func = [this.checkType1, this.checkType2, this.checkType3, this.checkType4, this.checkType5,                    this.checkType6, this.checkType7, this.checkType8, this.checkType9];        // let tips = ["", "单张", "对子", "三张", "炸弹", "连对", "顺子", "四带二", "飞机", "四带三"];        for(let i = 0; i < func.length; ++i){            let obj = func[i](cards);            if(obj !== undefined){                // console.log(tips[obj.type]);                // console.log(JSON.stringify(obj));                return obj;            }        }    },    /**     * 检查是否为单张     * @param cards     * @return {{type: number, cards: Array, val: number}}     */    checkType1: function (cards) {        if(cards.length === 1){            return {                type:1,                cards: cards,                val: val(cards[0])            };        }    },    /**     * 检查是否为对子     * @param cards     * @return {{type: number, cards: Array, val: number}}     */    checkType2: function (cards) {        if(cards.length === 2){            if(val(cards[0]) === val(cards[1])){                return {                    type:2,                    cards: cards,                    val: val(cards[0])                };            }        }    },    /**     * 检查三张     * @param cards     * @return {{type: number, cards: Array, val: number}}     */    checkType3: function (cards) {        //记录每张牌的数量        let count = {};        let keys = [];        //三张，只能带一或二或不带        if(cards.length < 3 || cards.length > 5){            return undefined;        }        console.log("cards3 :",cards);        cards.forEach(el => {            let v = val(el);            if(count[v] !== undefined){                count[v] ++;            } else {                count[v] = 1;            }        });        keys = Object.keys(count);        //如果只有三张，并且三张都相同，则直接返回        if(cards.length === 3 && keys.length === 1){            return {                type: 3,                cards: [cards.slice(0)],                val: val(cards[0])            };        }        //如果是四张，则必然只有两种牌        if(cards.length === 4 && keys.length === 2 && (count[keys[0]] === 3 || count[keys[1]] === 3)){            let body = []; //主体            let tail = []; //带出的牌            let pai = count[keys[0]] === 3 ? parseInt(keys[0]) : parseInt(keys[1]);            console.log("cards4 :",cards);            cards.forEach((el) => {                if(val(el) === pai){                    body.push(el);                } else {                    tail.push(el);                }            });            return {                type: 3,                cards: [body, tail],                val: pai            };        }        //五张        if(cards.length === 5 && (keys.length === 3 || keys.length === 2)){            let body = []; //主体            let tail = []; //带出的牌            let pai = undefined;            //找到三张牌            keys.forEach(key => {                if(count[key] >= 3){                    pai = parseInt(key);                }            });            //如果没有找到三张相同的牌，则牌错误            if(pai !== undefined){                console.log("cards5 :",cards);                cards.forEach(el => {                    if(val(el) === pai && body.length < 3){                        body.push(el);                    } else {                        tail.push(el);                    }                });                return {                    type: 3,                    cards: [body, tail],                    val: pai                };            }        }    },    /**     * 检查炸弹     * @param {Array} cards     * @return {{type: number, cards: Array, val: number}}     */    checkType4: function (cards) {        if(cards.length === 4){            for(let i = 0; i < cards.length-1; ++i){                if(val(cards[i]) !== val(cards[i+1])){                    return undefined;                }            }            return {                type: 4,                cards: cards.slice(0),                val: val(cards[0])            };        }    },    /**     * 检查连对     * @param cards     * @return {*}     */    checkType5: function (cards) {        if(cards.length % 2 === 0) {            let count = {};            console.log("cards6 :",cards);            cards.forEach(el => {                let v = val(el);                if(count[v] !== undefined){                    count[v] ++;                } else {                    count[v] = 1;                }            });            //每种牌必然为2张            for(let key in count){                if(count[key] !== 2){                    return undefined;                }            }            let keys = sort(Object.keys(count));            if (isStraight(keys)){                return {                    type: 5,                    cards: cards.slice(0),                    min:parseInt(keys[0]),                    length: cards.length/2                }            }        }    },    /**     * 检查顺子     * @param cards     */    checkType6: function (cards) {        if(cards.length >= 5){            sort(cards, true);            if(isStraight(cards, true)){                return {                    type: 6,                    cards: cards,                    min: val(cards[0]),                    length: cards.length                };            }        }    },    /**     * 检查四带二     * @param cards     * @return {{type: number, cards: [*,*], val: undefined}}     */    checkType7: function (cards) {        //记录每张牌的数量        let count = {};        let keys = [];        let pai = undefined;        let body = [];        let tail = [];        if(cards.length === 6){            console.log("cards7 :",cards);            cards.forEach(el => {                let v = val(el);                if(count[v] !== undefined){                    count[v] ++;                } else {                    count[v] = 1;                }            });            keys = Object.keys(count);            for(let key in count){                if(count[key] === 4){                    pai = parseInt(key);                }            }            if(pai !== undefined){                console.log("cards8 :",cards);                cards.forEach(el => {                    if(val(el) === pai){                        body.push(el);                    } else {                        tail.push(el);                    }                });                return {                    type: 7,                    cards: [body, tail],                    val: pai                };            }        }    },    /**     * 检查飞机     * @param cards     * @param length 飞机长度     * @return {*}     */    checkType8: function (cards, length) {        let count = {};        let pais = []; //保存三张的飞机        //飞机长度        length = length === undefined ? 0 : length;        console.log("cards9 :",cards);        cards.forEach(el => {            let v = val(el);            if(count[v] !== undefined){                count[v] ++;            } else {                count[v] = 1;            }        });        for (let key in count){            if(count[key] >= 3){                pais.push(parseInt(key));            }        }        if(pais.length < 2){            return undefined;        }        //排序        sort(pais);        //找到最大的顺子        pais = findMaxStraight(pais);        console.log(pais);        if(pais.length > length && length > 0){            pais.splice(0, pais.length - length);        }        //判断是否有顺子        if(!pais){            return undefined;        }        let body = [];        let tail = [];        for(let i = 0; i < cards.length; ++i){            let isBody = false;            for(let j = 0; j < pais.length; ++j){                if(body[j] === undefined){                    body[j] = [];                }                if(body[j].length < 3 && val(cards[i]) === pais[j]){                    body[j].push(cards[i]);                    isBody = true;                }            }            if(!isBody){                tail.push(cards[i]);            }        }        return {            type: 8,            cards: [body, tail],            min: pais[0],            length: pais.length        };    },    /**     * 检查四带三      * @param cards     * @return {{type: number, cards: [*,*], val: undefined}}     */    checkType9: function (cards) {        //记录每张牌的数量        let count = {};        let keys = [];        let pai = undefined;        let body = [];        let tail = [];        if(cards.length === 7){            console.log("cards10 :",cards);            cards.forEach(el => {                let v = val(el);                if(count[v] !== undefined){                    count[v] ++;                } else {                    count[v] = 1;                }            });            keys = Object.keys(count);            for(let key in count){                if(count[key] === 4){                    pai = parseInt(key);                }            }            if(pai !== undefined){                console.log("cards11 :",cards);                cards.forEach(el => {                    if(val(el) === pai){                        body.push(el);                    } else {                        tail.push(el);                    }                });                return {                    type: 9,                    cards: [body, tail],                    val: pai                };            }        }    },    /**     * 比较两手牌类型是否相同     * @param left     * @param right     * @return {boolean} true=相同，反之不同     */    compareType: function (left, right) {        if(left.type !== right.type){            return false;        }        switch(left.type){            case 1: //单张            case 2: //对子            case 3: //三张            case 4: //炸弹            case 7: //四带二            case 9: //四带三                return true;            case 5: //连对            case 6: //顺子            case 8: //飞机                return left.length === right.length;        }    },    /**     * 比较两手牌大小     * @param left     * @param right     * @return {boolean}  左>右 = true     */    compare: function (left, right) {        if(left.type !== right.type){            if(left.type === 4){                return true;            }            return false;        }        switch(left.type){            case 1: //单张            case 2: //对子            case 3: //三张            case 4: //炸弹            case 7: //四带二            case 9: //四带三                return (transform(left.val) > transform(right.val)) ;            case 5: //连对            case 6: //顺子            case 8: //飞机                return transform(left.min) > transform(right.min);        }    },    /**     * 获取可以出的牌的数组     * @param oricards     * @param holds     * @param type     * @param lastCard     */    findValues(oricards, type, lastCard, noBomb, alert) {        let types = {};        let cards = oricards.concat();        let counts = this.getEveryPokerCounts(cards);        let bombIdxs = this.getBombs(counts);        let self = this;        //如果炸弹不可拆        // if (cc.gameargs.rule.gameRules.indexOf(1) > -1) {        bombIdxs.forEach(function (idx) {            let cans = [];            for (let i = 0; i < cards.length; i++) {                let value = cards[i];                if (self.valueToIdx(value) == idx) {                    cards.splice(i, 1);                    cans.push(idx);                    i-=1;                }            }            counts[idx] = 0;        });        // }        if (!!lastCard) {            type = [lastCard.type];        }        if (!!type) {        } else {            type = [PdkActType.danzhang, PdkActType.duizi, PdkActType.sandai, PdkActType.shunzi,                PdkActType.liandui, PdkActType.feiji, PdkActType.zhadan];        }        if (type.indexOf(PdkActType.zhadan) > -1) {            if (bombIdxs.length > 0) {                if (!!lastCard) {                    let min = this.getMinPokerIdx(lastCard);                    bombIdxs = bombIdxs.filter(function (obj) {                        return obj[0] > min;                    })                }            }        }        if (bombIdxs.length > 0) {            types[(PdkActType.zhadan).toString()] = bombIdxs;        }        if (type.indexOf(PdkActType.danzhang) > -1) {            let list = this.getDanzhangs(counts, lastCard, alert);            if (list.length > 0) {                types[PdkActType.danzhang.toString()] = list;            }        }        if (type.indexOf(PdkActType.duizi) > -1) {            let list = this.getDuizi(counts, lastCard);            if (list.length > 0) {                types[PdkActType.duizi.toString()] = list;            }        }        if (type.indexOf(PdkActType.sandai) > -1) {            let list = this.getSandais(counts, lastCard);            if (list.length > 0) {                types[PdkActType.sandai.toString()] = list;            }        }        if (type.indexOf(PdkActType.liandui) > -1) {            let list = this.getLianduis(counts, lastCard);            if (list.length > 0) {                types[PdkActType.liandui.toString()] = list;            }        }        if (type.indexOf(PdkActType.shunzi) > -1) {            let list = this.getShunzis(counts, lastCard);            if (list.length > 0) {                types[PdkActType.shunzi.toString()] = list;            }        }        if (type.indexOf(PdkActType.feiji) > -1) {            let list = this.getFeijis(counts, lastCard, noBomb);            if (list.length > 0) {                types[PdkActType.feiji.toString()] = list;            }        }        return types;    },    getMinPokerIdx (lastCard) {        let cards = lastCard.cards;        let value = 0;        let list = [];        if (!!cards) {            list = cards.concat();            value = cards[0];            while (typeof (value) != 'number') {                list = value.concat();                value = value[0];            }        }        let compare = function (a, b) {            let aa = a % 13;            if (a % 13 === 0) {                aa = 100;            } else if (a % 13 === 1) {                aa = 200;            }            let bb = b % 13;            if (b % 13 === 0) {                bb = 100;            } else if (b % 13 === 1) {                bb = 200;            }            return aa - bb;        };        list.sort(compare);        return this.valueToIdx(list[0]);    },    getPokersLen (lastCard) {        let cards = lastCard.cards;        let len = 0;        if (!!cards) {            let value = cards[0];            if (typeof (value) != 'number') {                len = value.length;            } else {                let type = lastCard.type;                if (type == PdkActType.liandui) {                    len = cards.length/2;                } else {                    len = cards.length;                }            }        }        return len;    },    /**     * 获得单张数组     * @param counts     * @param lastCard     * @return {Array}     */    getDanzhangs(counts, lastCard, alert) {        let list = [];        let min = 1;        if (!!lastCard) {            min = this.getMinPokerIdx(lastCard);        }        let all = {};        let max = 2;        for (let i = 2; i < counts.length; i++) {            let a = counts[i];            if (a > 0 && a < 4 && i > min) {                if (!all[a.toString()]) {                    all[a.toString()] = [];                }                all[a.toString()].push([i]);                max = i;            }        }        if (alert) {            if (max > min) {                list = [[max]];            }        } else {            for (let i = 1; i < 5; i++) {                let arr = all[i.toString()];                if (!!arr && arr.length > 0) {                    list = list.concat(arr);                }            }        }        return list;    },    /**     * 获得对子数组     * @param counts     * @param lastCard     * @return {Array}     */    getDuizi(counts, lastCard) {        let list = [];        let min = 1;        if (!!lastCard) {            min = this.getMinPokerIdx(lastCard);        }        let all = {};        for (let i = 2; i < counts.length; i++) {            let a = counts[i];            if (a > 1 && a < 4 && i > min) {                if (!all[a.toString()]) {                    all[a.toString()] = [];                }                all[a.toString()].push([i]);            }        }        for (let i = 1; i < 5; i++) {            let arr = all[i.toString()];            if (!!arr && arr.length > 0) {                list = list.concat(arr);            }        }        return list;    },    /**     * 获得三带数组     * @param counts     * @param lastCard     * @return {Array}     */    getSandais(counts, lastCard) {        let list = [];        let idxs = [];        let min = 1;        if (!!lastCard) {            min = this.getMinPokerIdx(lastCard);        }        for (let i = 2; i < counts.length-1; i++) {            let a = counts[i];            if (a == 3 && i > min) {                idxs.push(i);                list.push(idxs.slice());                idxs.length = 0;            }        }        return list;    },    /**     * 获得顺子数组     * @param counts     * @param lastCard     * @return {Array}     */    getShunzis(counts, lastCard) {        let list = [];        let idxs = [];        let min = 1;        let len = 5;        if (!!lastCard) {            min = this.getMinPokerIdx(lastCard);            len = this.getPokersLen(lastCard);        }        for (let i = 2; i < counts.length-1; i++) {            let a = counts[i];            if (a > 0 && i > min) {                idxs.push(i);                if (i == counts.length-2) {                    if (idxs.length >= len) {                        list.push(idxs.slice());                    }                    idxs.length = 0;                }            } else {                if (idxs.length >= len) {                    list.push(idxs.slice());                }                idxs.length = 0;            }        }        if (!!lastCard) {            list = this.getFinalList(list, len);        }        return list;    },    /**     * 过滤能出的数组     * @param list     * @param len     * @return {Array}     */    getFinalList (list, len) {        let finalList = [];        if (list.length > 0) {            for (let i = 0; i < list.length; i++) {                let start = 0;                let objs = list[i];                if (objs.length == len) {                    finalList.push(objs);                } else {                    while (objs.length-start >= len) {                        finalList.push(objs.slice(start, len+start));                        start+=1;                    }                }            }        }        return finalList;    },    /**     * 获得连队数组     * @param counts     * @param lastCard     * @return {Array}     */    getLianduis(counts, lastCard) {        let list = [];        let idxs = [];        let min = 1;        let len = 2;        if (!!lastCard) {            min = this.getMinPokerIdx(lastCard);            len = this.getPokersLen(lastCard);        }        for (let i = 2; i < counts.length-1; i++) {            let a = counts[i];            if (a > 1 && i > min) {                idxs.push(i);                if (i == counts.length-2) {                    if (idxs.length >= len) {                        list.push(idxs.slice());                    }                    idxs.length = 0;                }            } else {                if (idxs.length >= len) {                    list.push(idxs.slice());                }                idxs.length = 0;            }        }        if (!!lastCard) {            list = this.getFinalList(list, len);        }        return list;    },    /**     * 获得飞机数组     * @param counts     * @param lastCard     * @return {Array}     */    getFeijis(counts, lastCard, noBomb) {        let list = [];        let idxs = [];        let min = 1;        let len = 2;        if (!!lastCard) {            min = this.getMinPokerIdx(lastCard);            len = this.getPokersLen(lastCard);        }        for (let i = 2; i < counts.length-1; i++) {            let a = counts[i];            if ((noBomb ? a == 3 : a > 2) && i > min) {                idxs.push(i);                if (i == counts.length-2) {                    if (idxs.length >= len) {                        list.push(idxs.slice());                    }                    idxs.length = 0;                }            } else {                if (idxs.length >= len) {                    list.push(idxs.slice());                }                idxs.length = 0;            }        }        if (!!lastCard) {            list = this.getFinalList(list, len);        }        return list;    },    /**     * 牌值转idx     * @param value     * @return {number}     */    valueToIdx(value) {        let idx = value%13;        if (idx < 2) {            idx+=13;        }        return idx;    },    /**     * 获取每种牌的张数     * @param holds     * @return {number[]}     */    getEveryPokerCounts(holds) {        let list = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];        holds.forEach(function (value) {            let idx = this.valueToIdx(value);            list[idx]+=1;        }.bind(this));        return list;    },    /**     * 获取炸弹     * @param counts     * @return {Array}     */    getBombs(counts) {        let list = [];        let idxs = [];        counts.forEach(function (a, idx) {            if (a == 4) {                idxs.push(idx);                list.push(idxs.slice());                idxs.length = 0;            }        });        return list;    },    /**     * 检查牌是否能出     * @param types     * @param lastCard     * @return {}     */    checkChupai(values, types, holds, lastCard, rule) {        for (let type in types) {            /*** 检查单张 */            if (parseInt(type) == PdkActType.danzhang) {                if (values.length == 1) {                    return {can: true, auto: (values.length == holds.length)};                }            }            /*** 检查对子 */            if (parseInt(type) == PdkActType.duizi) {                if (values.length == 2) {                    return {can: true, auto: (values.length == holds.length)};;                }            }            /*** 检查三带 */            if (parseInt(type) == PdkActType.sandai) {                /*** 如果是5张则直接出 */                if (values.length == 5) {                    return {can: true, auto: (values.length == holds.length)};;                }                /*** 如果少于5张则检查规则 而且必须是最后一手牌 */                if (values.length < 5) {                    if (values.length == holds.length) {                        if (!!lastCard) {                            if (rule.playTypes.indexOf(2) > -1) {                                return {can: true, auto: true};                            }                        } else {                            if (rule.playTypes.indexOf(1) > -1) {                                return {can: true, auto: true};                            }                        }                    }                }            }            /*** 检查炸弹 */            if (parseInt(type) == PdkActType.zhadan) {                if (values.length == 4) {                    return {can: true, auto: (values.length == holds.length)};                }                /*** 允许四带二 */                if (values.length == 6) {                    if (rule.gameRules.indexOf(2) > -1) {                        return {can: true, auto: false};                    }                }                /*** 允许四带三 */                if (values.length == 7) {                    if (rule.gameRules.indexOf(3) > -1) {                        return {can: true, auto: false};                    }                }            }            /*** 检查顺子 */            if (parseInt(type) == PdkActType.shunzi) {                let cards = types[type];                if (cards.length == 1 && values.length == cards[0].length) {                    return {can: true, auto: (values.length == holds.length)};                }            }            /*** 检查连对 */            if (parseInt(type) == PdkActType.liandui) {                let cards = types[type];                if (cards.length == 1 && values.length == cards[0].length*2) {                    return {can: true, auto: (values.length == holds.length)};                }            }            /*** 检查飞机 */            if (parseInt(type) == PdkActType.feiji) {                let cards = types[type];                if (cards.length == 1 && values.length == cards[0].length*5) {                    return {can: true, auto: (values.length == holds.length)};                }                /*** 如果少于则检查规则 而且必须是最后一手牌 */                if (values.length < cards[0].length*5) {                    if (values.length == holds.length) {                        if (!!lastCard) {                            if (rule.playTypes.indexOf(4) > -1) {                                return {can: true, auto: true};                            }                        } else {                            if (rule.playTypes.indexOf(3) > -1) {                                return {can: true, auto: true};                            }                        }                    }                }            }        }        return {can: false, auto: false};    },    /**     * 检查是否有黑桃三     * @param values     * @return {boolean}     */    hasHeitao3(values) {        let has = values.indexOf(41) > -1;        return has;    }};// let alg = module.exports;//// function pook(cards) {//     let arr = ["",'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', "K"];//     let hua = ["♦", "♣", "♥", "♠"];//     let str = "";//     cards.forEach(el => {//         str += hua[type(el)] +":"+ arr[val(el)] + ",";//     });//     console.log(str);// }// let cards = [31, 8, 21, 7, 19, 5, 11, 12, 26, 20, 32, 46, 39, 44, 45];// let cards = [31, 5, 44, 45];// let cards = [10, 8, 21, 11, 7, 5, 32, 19, 26, 20, 46, 33, 31, 44, 45];// let counts = {};// cards.forEach((el) => {//     let v = alg.val(el);//     if (counts[v] === undefined) {//         counts[v] = 1;//     } else {//         counts[v]++;//     }// });// sort(cards, true);// pook(cards);// let result = alg.getType1({val:12}, cards, counts);  //找单张// let result = alg.getType2({val:4}, cards, counts);  //找对子// let result = alg.getType3({val:3}, cards, counts);  //找三张// let result = alg.getType4({val:6}, cards, counts);  //找到炸弹// let result = alg.getType5({min:10, length:2}, cards, counts);  //找到连对// let result = alg.getType6({min:9, length:5}, cards, counts);  //找到顺子// let result = alg.getType7({val:6}, cards, counts);  //找到四带三// let result = alg.getType8({min:5, length:3}, cards, counts);  //找到一个飞机// let result = alg.getType9({val:8}, cards, counts);  //找到四带三// pook(result);// console.log(result);// console.log(module.exports.parseType(a));// module.exports.parseType([5,8,3, 4,7,6]);// console.log(module.exports.checkType6([19,5,43,16,2]));/*let arr = [40,13,39,12,38,25,11,23,9,32,31,5,17,29,16,15];let counts = {};arr.forEach(el => {    if(counts[val(el)] === undefined){        counts[val(el)] = 1;    } else {        counts[val(el)] ++;    }});console.log(module.exports.findType6({type: 6,    cards: [ 15, 16, 17, 5, 32 ],    min: 3,    length: 5 }, arr, counts));*/// console.log(module.exports.findType4({type: 1, cards: [ 13 ], val: 13, uid: 100008 },//     [20, 42, 5, 7, 21, 50, 18, 2, 47, 22, 49, 41, 10, 6, 4, 36  ], {'1': 4,//     '6': 3,//     '7': 1,//     '8': 1,//     '9': 3,//     '10': 1,//     '11': 1,//     '12': 1,//     '13': 3   }));// console.log(module.exports.findType5({//     min: 3,//     length: 2// }, [], {'1': 4,//     '2': 3,//     '7': 1,//     '8': 1,//     '9': 3,//     '10': 1,//     '11': 1,//     '12': 1,//     '13': 1   }));// console.log(findMaxStraight([2,4,6,9]));// console.log(module.exports.checkType8([12, 12, 12, 10, 10, 10, 11,11,11], 2));