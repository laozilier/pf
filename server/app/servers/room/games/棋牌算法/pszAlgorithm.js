/** * Created by T-Vick on 2017/9/29. *//** * 金花牌型 * @type {{WU_LONG: number, DUI_ZI: number, SHUN_ZI: number, JIN_HUA: number, JIN_HUA_SHUN: number, BAO_ZI: number}} */let Pattern = {    WU_LONG: 0, // 乌龙(散牌)    DUI_ZI: 1,    SHUN_ZI: 2,    JIN_HUA: 3,    JIN_HUA_SHUN: 4,    SB_JIN_HUA: 5,    SB_SHUN_ZI: 6,    SB_DI_LONG: 7,    SB_TIAN_LONG: 8,    SB_JIN_HUA_SHUN: 9,    SB_SHUN_JIN_DI: 10,    SB_SHUN_JIN_TIAN: 11,    BAO_ZI: 12};/** * 获取单张牌的牌值 * @param card * @param isAlargest * @returns {number} */function val(card, isAlargest) {    // todo: 根据选项判断牌是在三公中的值还是在金花中的值    let value = card % 13;    if (card == 52) {        return 16;    } else if (card == 53) {        return 17;    } else if (isAlargest) {        let i = [0].indexOf(value);        if (i > -1) {            return 13 + i + 1;        }    }    return (value + 1);}/** * 获取牌的花色 * 0.方片；1.梅花；2.红桃；3.黑桃 * @param card * @return {number} 类型  0.方片；1.梅花；2.红桃；3.黑桃 */function getColor(card) {    if ([52, 53].indexOf(card) > -1) {        return 4;    }    return Math.floor(card / 13);}/** * 两张牌是否相连 * @return {boolean} 如果相连返回true */function isContinuous(max, min) {    // todo: 2连不连（连队和顺子）    if ([15, 16, 17].indexOf(max) > -1 || [15, 16, 17].indexOf(min) > -1) {        return false;    }    if (max - min === 1) {        return true;    }}/** * 查找数量相同，且连续的值 * @param cardsMap * @param continueCount * @returns {Array} */function findContinueVals(cardsMap, continueCount) {    let continueList = [];    for (let i = 0; i < cardsMap.sortedValsDesc.length - 1; i++) {        let v = cardsMap.sortedValsDesc[i];        if (cardsMap.valCardsMap[v].length < continueCount) {            continue;        }        let lianVal = [v];        for (let j = i + 1; j < cardsMap.sortedValsDesc.length; j++) {            let nextV = cardsMap.sortedValsDesc[j];            if (cardsMap.valCardsMap[nextV].length < continueCount) {                break;            }            let curV = lianVal[0];            if (isContinuous(curV, nextV)) {                lianVal.unshift(nextV);            } else {                break;            }        }        if (lianVal.length > 1) {            continueList.unshift(lianVal);            i += lianVal.length - 1;        }    }    return continueList;}/** * 获取值牌映射 * @param cards * @returns {{cards: Array, valCardsMap, sortedVals: number[]}} */function getCardsMap(cards, isAlargest) {    //记录每张牌的数量    let valCardsMap = {};    let tempCards = [];    cards.forEach(el => {        let v = val(el, isAlargest);        if (valCardsMap[v]) {            valCardsMap[v].push(el);        } else {            valCardsMap[v] = [el];        }    });    for (let val in valCardsMap) {        valCardsMap[val].sort(function (a, b) {            return b - a        });    }    let sortedVals = Object.keys(valCardsMap).map(function (val) {        return parseInt(val)    });    for (let i = 0; i < sortedVals.length - 1; i++) {        for (let j = i + 1; j < sortedVals.length; j++) {            // 数量多的考前            if (valCardsMap[sortedVals[j]].length > valCardsMap[sortedVals[i]].length) {                let temp = sortedVals[i];                sortedVals[i] = sortedVals[j];                sortedVals[j] = temp;            }            // 数量相同的牌值大的靠前            if (valCardsMap[sortedVals[j]].length == valCardsMap[sortedVals[i]].length) {                if (sortedVals[j] > sortedVals[i]) {                    let temp = sortedVals[i];                    sortedVals[i] = sortedVals[j];                    sortedVals[j] = temp;                }            }        }    }    let sortedValsDesc = sortedVals.concat();    for (let i = 0; i < sortedValsDesc.length - 1; i++) {        for (let j = i + 1; j < sortedValsDesc.length; j++) {            if (sortedValsDesc[j] > sortedValsDesc[i]) {                let temp = sortedValsDesc[i];                sortedValsDesc[i] = sortedValsDesc[j];                sortedValsDesc[j] = temp;            }        }    }    for (let val of sortedVals) {        tempCards = tempCards.concat(valCardsMap[val]);    }    // console.log(valCardsMap,  sortedVals);    return {cards: tempCards, valCardsMap, sortedVals, sortedValsDesc};}/** * 获取花色与牌的映射 * @param cards * @returns {{cards: Array, colorCardsMap, sortedColors: number[]}} */function getColorMap(cards) {    //记录每张牌的数量    let colorCardsMap = {};    let tempCards = [];    cards.forEach(c => {        let color = getColor(c);        if (colorCardsMap[color]) {            colorCardsMap[color].push(c);        } else {            colorCardsMap[color] = [c];        }    });    // for (let color in colorCardsMap) {    //     colorCardsMap[color].sort(function(a, b) {return b - a});    // }    let sortedColors = Object.keys(colorCardsMap).map(function (color) {        return parseInt(color)    });    for (let i = 0; i < sortedColors.length - 1; i++) {        for (let j = i + 1; j < sortedColors.length; j++) {            // 数量多的考前            if (colorCardsMap[sortedColors[j]].length > colorCardsMap[sortedColors[i]].length) {                let temp = sortedColors[i];                sortedColors[i] = sortedColors[j];                sortedColors[j] = temp;            }            // 数量相同的牌值大的靠前            if (colorCardsMap[sortedColors[j]].length == colorCardsMap[sortedColors[i]].length) {                if (sortedColors[j] > sortedColors[i]) {                    let temp = sortedColors[i];                    sortedColors[i] = sortedColors[j];                    sortedColors[j] = temp;                }            }        }    }    for (let val of sortedColors) {        tempCards = tempCards.concat(colorCardsMap[val]);    }    // console.log(colorCardsMap,  sortedColors);    return {cards: tempCards, colorCardsMap, sortedColors};}/** * 获取一首牌的值 * @param cardsMap * @param pattern * @returns {number} */function getPatternValue(cardsMap, pattern) {    let valStr = '0x';    switch (pattern) {        case Pattern.BAO_ZI:        case Pattern.DUI_ZI:            for (let v of cardsMap.sortedVals) {                let cs = cardsMap.valCardsMap[v];                for (let c of cs) {                    valStr += val(c, true).toString(16);                }            }            break;        case Pattern.SB_JIN_HUA_SHUN:        case Pattern.SB_JIN_HUA:        case Pattern.SB_SHUN_ZI:        case Pattern.JIN_HUA_SHUN:        case Pattern.JIN_HUA:        case Pattern.SHUN_ZI:        case Pattern.WU_LONG:            // 金花比顺子大A23是最小的顺子/金花顺            if ((pattern == Pattern.JIN_HUA_SHUN || pattern == Pattern.SHUN_ZI) && cardsMap.sortedValsDesc.join('') == '1432') {                valStr = '0';            } else {                for (let v of cardsMap.sortedValsDesc) {                    let cs = cardsMap.valCardsMap[v];                    for (let c of cs) {                        valStr += val(c, true).toString(16);                    }                }            }            break;        case Pattern.SB_SHUN_JIN_TIAN:        case Pattern.SB_SHUN_JIN_DI:        case Pattern.SB_TIAN_LONG:        case Pattern.SB_DI_LONG:            valStr = '0';            break;        default:            return 0;    }    return parseInt(valStr) + pattern * 10000;}/** * 寻找顺子 * @param cardsMap * @param length * @returns {*} */function findABC(cardsMap, length) {    cardsMap = JSON.parse(JSON.stringify(cardsMap));    // todo: 金花的A23算不算顺子    if (cardsMap.valCardsMap[14]) {        cardsMap.valCardsMap[1] = cardsMap.valCardsMap[14];        cardsMap.sortedValsDesc.push(1);    }    let continueList = findContinueVals(cardsMap, 1);    if (!Array.isArray(continueList) || !continueList.length) {        return;    }    // list中的值是从小到大排序的    let list = null;    for (let lianVal of continueList) {        if (lianVal.length >= length) {            list = lianVal;            break;        }    }    if (!list) {        return;    }    let shunZi = [];    // 优先取最大的顺子    for (let i = list.length - 1; i > -1; i--) {        let v = list[i];        shunZi.unshift(cardsMap.valCardsMap[v][0]); // 直接从黑桃先去        if (shunZi.length == length) {            break;        }    }    return shunZi;}// 检查金花牌型function checkPattern(cards, algRule) {    // todo: 不同的玩法规则，牌值的大小是不一样的    let cardsMap = getCardsMap(cards, true);    let colorMap = getColorMap(cards);    let maxCount = cardsMap.valCardsMap[cardsMap.sortedVals[0]].length;    let maxColor = colorMap.colorCardsMap[colorMap.sortedColors[0]].length;    // 豹子    if (maxCount == 3) {        return {            cards: cards,            pattern: Pattern.BAO_ZI,            value: getPatternValue(cardsMap, Pattern.BAO_ZI),            xi: 10        };    }    let shunZi = findABC(cardsMap, 3);    if (shunZi) {        // 金华顺        if (maxColor == 3) {            if (algRule.flushBTAbc) {                return {                    cards: cards,                    pattern: Pattern.JIN_HUA_SHUN,                    value: getPatternValue(cardsMap, Pattern.JIN_HUA_SHUN),                    xi: 5                };            } else {                let valStr = cardsMap.sortedVals.join('');                // 顺金天龙                if (valStr == '141312') {                    return {                        cards: cards,                        pattern: Pattern.SB_SHUN_JIN_TIAN,                        value: getPatternValue(cardsMap, Pattern.SB_SHUN_JIN_TIAN),                        xi: 5                    }                }                // 顺金地龙                if (valStr == '1432') {                    return {                        cards: cards,                        pattern: Pattern.SB_SHUN_JIN_DI,                        value: getPatternValue(cardsMap, Pattern.SB_SHUN_JIN_DI),                        xi: 5                    }                }                // 顺子比金花大的顺金                return {                    cards: cards,                    pattern: Pattern.SB_JIN_HUA_SHUN,                    value: getPatternValue(cardsMap, Pattern.SB_JIN_HUA_SHUN),                    xi: 5                };            }        }        if (algRule.flushBTAbc) {            // 顺子            return {                cards: cards,                pattern: Pattern.SHUN_ZI,                value: getPatternValue(cardsMap, Pattern.SHUN_ZI)            };        } else {            let valStr = cardsMap.sortedVals.join('');            // 天龙            if (valStr == '141312') {                return {                    cards: cards,                    pattern: Pattern.SB_TIAN_LONG,                    value: getPatternValue(cardsMap, Pattern.SB_TIAN_LONG)                }            }            // 地龙            if (valStr == '1432') {                return {                    cards: cards,                    pattern: Pattern.SB_DI_LONG,                    value: getPatternValue(cardsMap, Pattern.SB_DI_LONG)                }            }            // 顺子比金花大的顺子            return {                cards: cards,                pattern: Pattern.SB_SHUN_ZI,                value: getPatternValue(cardsMap, Pattern.SB_SHUN_ZI)            };        }    }    // 金花    if (maxColor == 3) {        if (algRule.flushBTAbc) {            return {                cards: cards,                pattern: Pattern.JIN_HUA,                value: getPatternValue(cardsMap, Pattern.JIN_HUA)            };        } else {            return {                cards: cards,                pattern: Pattern.SB_JIN_HUA,                value: getPatternValue(cardsMap, Pattern.SB_JIN_HUA)            };        }    }    // 对子    if (maxCount == 2) {        return {            cards: cards,            pattern: Pattern.DUI_ZI,            value: getPatternValue(cardsMap, Pattern.DUI_ZI)        };    }    // 乌龙    return {        cards: cards,        pattern: Pattern.WU_LONG,        value: getPatternValue(cardsMap, Pattern.WU_LONG)    };}/** * 发牌 * @param count 发几手牌 * @param algRule  牛牛规则 * @param {Array} [cards]  一副牌 * @return {Object} */exports.deal = function(count, algRule, cards) {    //保存实际要发到玩家手上的牌    // let holds = [];    let holdsList = [];    let max = 10;    //发十手牌到这个数组，会从中间抽掉多余的牌    let allHolds = [[], [], [], [], [], [], [], [], [], []];    //下一副牌    let nextCards = [];    if(!cards){  //如果没有一副牌，则创建一手牌        cards = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];        //洗乱牌        for(let i = 0; i < cards.length; ++i){            let n = cards[i];            let ii = parseInt(Math.random() * cards.length);            cards[i] = cards[ii];            cards[ii] = n;        }    } else { //随机打乱十次        for (let i = 0; i < 10; ++i){            let i = parseInt(Math.random() * cards.length);            let j = parseInt(Math.random() * cards.length);            let n = cards[i];            cards[i] = cards[j];            cards[j] = n;        }    }    //发牌    for(let i = 0; i < cards.length; ++i){        if(i < max * 3){            let seat = i%max;            allHolds[seat].push(cards[i]);        }        nextCards.push(cards[i]);    }    //抽掉多余的牌    for (let i = 0; i < count; ++i){        let randomId = Math.randomRange(0, allHolds.length);        // let hold = allHolds.splice(randomId, 1)[0];        let holds = allHolds.splice(randomId, 1)[0];        holdsList.push(holds);    }    // todo: 配牌  金花       // 顺子  ♠4♥56       顺金地龙       顺金天龙   顺金            地龙          天龙          豹子    // let makeHolds = [[1, 2, 43], [42, 30, 31], [13, 14, 15], [0, 11, 12], [16, 17, 18], [26, 27, 41], [37, 38, 39], [7, 20, 33], [28, 40, 5], [36, 6, 9]];    // let makeHolds = [[1, 2, 43], [1, 2, 43], [1, 2, 43], [1, 2, 43], [1, 2, 43], [7, 20, 33], [7, 20, 33], [7, 20, 33], [7, 20, 33], [7, 20, 33]];    // let makeHolds = [[1, 2, 17], [3, 26, 43], [42, 30, 31], [27, 29, 35], [16, 17, 18], [7, 20, 33], [1, 2, 17], [1, 2, 17], [1, 2, 17], [1, 2, 17]];// 六种牌型    // holdsList = makeHolds.splice(0, count);    //计算结果    //holdsList = [[51,1,14], [38,24,7]];    for(let i = 0; i < count; ++i){        let holds = holdsList[i];        // todo: 计算每首牌的结果        let final = {cards: holds, pattern: checkPattern(holds, algRule)};        holdsList[i] = final;    }    holdsList.sort((a, b) => {        return b.pattern.value - a.pattern.value;    });    return {        holds: holdsList,        cards: nextCards    };};