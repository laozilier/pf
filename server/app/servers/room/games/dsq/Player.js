/** * Created by apple on 2017/11/1. */let BasePlayer = require('../BasePlayer');let alg = require('./algorithm');class Player extends BasePlayer{    constructor(main, uid){        super(main);        this.isTrusteeship = false;        this.uid = uid;        this.initEvent();    }    initEvent(){        this.on('fanpai', this.fanpai);        this.on('move', this.move);        this.on('lose', this.lose);        this.on('over', this.over);    }    /**     * 设置托管状态     * @param has     */    setTrusteeship(has) {        this.isTrusteeship = has;        // 如果进入托管状态，则判断这一把是否需要自动操作        if (this._main.turnUid != this.uid) {            return;        }        if(has){            this._main.nextTurn();        }    }    /**     * 玩家操作 翻牌     */    fanpai(data) {        if (this._main.turnUid != this.uid) {            return;        }        //[1 ,1]        let row = data[0];        if (row == undefined || row < 0 || row > 3) {            return;        }        let col = data[1];        if (col == undefined || col < 0 || col > 3) {            return;        }        let curChess = this._main.curChess;        let value = curChess[row][col];        if (value != -1) {            return;        }        let actvalue = this._main.chess[row][col];        curChess[row][col] = actvalue;        let senddata = {id: actvalue, index: alg.erweiToYiwei(row, col), uid: this.uid, curChess: curChess};        this.sendAll('fanpai', senddata);        this._main.nextTurn();    }    /**     * 玩家操作 移动     */    move(data) {        if (this._main.turnUid != this.uid) {            return;        }        let from = data.from;        if (from == undefined) {            return;        }        let fromrow = from[0];        if (fromrow == undefined || fromrow < 0 || fromrow > 3) {            return;        }        let fromcol = from[1];        if (fromcol == undefined || fromcol < 0 || fromcol > 3) {            return;        }        let curChess = this._main.curChess;        let fromvalue = curChess[fromrow][fromcol];        if (fromvalue < 1) {            return;        }        let fromidx = this.chess.indexOf(fromvalue);        if (fromidx < 0) {            return;        }        let to = data.to;        if (to == undefined) {            return;        }        let torow = to[0];        if (torow == undefined || torow < 0 || torow > 3) {            return;        }        let tocol = to[1];        if (tocol == undefined || tocol < 0 || tocol > 3) {            return;        }        if (!alg.isNear(fromrow, fromcol, torow, tocol)) {            return;        }        let tovalue = curChess[torow][tocol];        if (tovalue < 0) {            return;        }        data.fromIndex = alg.erweiToYiwei(fromrow, fromcol);        data.toIndex = alg.erweiToYiwei(torow, tocol);        data.uid = this.uid;        if (tovalue == 0) {            curChess[fromrow][fromcol] = 0;            curChess[torow][tocol] = fromvalue;            data.curChess = curChess;            data.res = 2;            this.sendAll('movesuc', data);            this._main.nextTurn();            return;        }        let idx = this.chess.indexOf(tovalue);        if (idx > -1) {            return;        }        let res = alg.compareCards(fromvalue, tovalue);        if (res == -1) {            curChess[fromrow][fromcol] = 0;            this.chess.splice(fromidx, 1);            data.curChess = curChess;            data.res = res;            this.sendAll('movesuc', data);            this._main.maxTurn = 0;            this._main.nextTurn(true);            return;        }        if (res == 0) {            curChess[fromrow][fromcol] = 0;            curChess[torow][tocol] = 0;            this.chess.splice(fromidx, 1);            this.delOtherPlayerChess(tovalue);            data.curChess = curChess;            data.res = res;            this.sendAll('movesuc', data);            this._main.nextTurn(true);            return;        }        if (res == 1) {            curChess[fromrow][fromcol] = 0;            curChess[torow][tocol] = fromvalue;            this.delOtherPlayerChess(tovalue);            data.curChess = curChess;            data.res = res;            this.sendAll('movesuc', data);            this._main.maxTurn = 0;            this._main.nextTurn(true);        }        //[1, 1], [1, 2];    }    /** 玩家操作 认输**/    lose() {        this._main.lose(this.uid);    }    /** 玩家操作 终止对局**/    over() {        this._main.over(this.uid);    }    delOtherPlayerChess(v) {        let otheruid = undefined;        for (let i = 0; i < this._main.uids.length; i++) {            let a = this._main.uids[i];            if (a != this.uid) {                otheruid = a;                break;            }        }        if (!!otheruid) {            let otherPlayer = this._main.player(otheruid);            if (!!otherPlayer) {                let idx = otherPlayer.chess.indexOf(v);                if (idx > -1) {                    otherPlayer.chess.splice(idx, 1);                }            }        }    }    /**     * 发送给自己     */    getInfo(){        let data = {            isTrusteeship: this.isTrusteeship,        };        return data;    }    /**     * 发送给其它玩家的信息     */    getOtherInfo(){        let data = {            isTrusteeship: this.isTrusteeship,        };        return data;    }}module.exports = Player;