/** * Created by apple on 2017/11/1. */let BaseMain = require('../BaseMain');let Player = require('./Player');let alg = require('./algorithm');/** *  规则信息 account:cc.user.account, //账号 sign:cc.user.sign,       //sign证验码 uid:cc.user.uid, game_type:0, max:0,        //最大局数 halfway:true, //是否中途加入 game_rule:{                difen:0,        底分 id            } */class Main extends BaseMain {    /**     *     * @param uids  玩家uid列表     * @param rule  游戏规则     */    constructor(uids, rule, room) {        super(room);        /**         * @type {[]}         * */        this.players = []; //玩家对象        this.uids = uids; //玩家uid列表        this.ante = rule.ante || 0;        this.actlist = [];        this.cid = room.cid;        this.winner = undefined;        //创建玩家        this.uids.forEach((uid, i) => {            let player = new Player(this);            player.uid = uid;            player.seatId = i;            player.chess = [];            player.type = i;            for (let j = 1; j < 9; j++) {                player.chess.push(i*10+j);            }            this.players.push(player);        }, this);        //发牌        this.chess = alg.deal();        this.curChess = [[-1,-1,-1,-1],[-1,-1,-1,-1],[-1,-1,-1,-1],[-1,-1,-1,-1]];        this.maxTurn = 0;        this.needCheckTurn = false;    }    /**     * 计时器     * @param cb     */    schedule(cb) {        this.clearTimeout(this.timeoutId);        this.optEndTime = Date.now() + (autoTimes[this.status] * 1000);        let times = (autoTimes[this.status] * 1000);        this.timeoutId = this.setTimeout(cb, times);    }    player(uid) {        for (let i = 0; i < this.players.length; ++i) {            if (this.players[i].uid === parseInt(uid)) {                return this.players[i];            }        }        return null;    }    /**     * 游戏开始的接口     */    begin() {        let types = {};        this.players.forEach(function (el) {            types[el.uid] = el.type;        }, this);        this.sendAll("gameBegin", {uids: this.uids, types: types}); //发送游戏开始        this.nextTurn();    }    /** 轮转 **/    nextTurn(need) {        this.clearTimeout(this.operatTimeoutId); //清空上一个超时计时器        this.clearTimeout(this.nextTimeoutId); //清空上一个轮转计时器        /** 先检查输赢 **/        if (!!this._upscoreed) {            return;        }        if (this.needCheckTurn) {            this.maxTurn+=1;        }        if ((need || this.needCheckTurn) && this.isGameOver()) {            return;        }        if (this.turnUid == undefined) {            let idx = Math.randomRange(0, this.uids.length);            this.turnUid = this.uids[idx] || this.uids[0];        } else {            let idx = this.uids.indexOf(this.turnUid);            idx+=1;            if (idx >= this.uids.length) {                idx = 0;            }            this.turnUid = this.uids[idx];        }        let maxTimeout = !!this.cid ? 30000 : 90000;        this.operatTime = Date.now(); //操作开始时间        this.operatTimeoutId = this.setTimeout(() => {            this.lose(this.turnUid);        }, maxTimeout);        this.nextTimeoutId = this.setTimeout(() => {            this.sendAll('turn', {uid: this.turnUid, auto: maxTimeout});        }, 1000);    }    /**     * 玩家认输     * @param loseuid     */    lose(loseuid) {        let winuid = undefined;        for (let i = 0; i < this.uids.length; i++) {            let uid = this.uids[i];            if (loseuid != uid) {                winuid = uid;                break;            }        }        if (!!winuid) {            this.winner = winuid;            this.upScore(winuid, loseuid, this.ante);        }    }    /**     * 玩家终止对局     * @param loseuid     */    over() {        let p0 = this.players[0];        let p1 = this.players[1];        /** 平局 **/        this.upScore(p0.uid, p1.uid, 0);    }    /**     * 检查输赢     */    isGameOver() {        let p0 = this.players[0];        let p1 = this.players[1];        if ((p0.chess.length == 0 && p1.chess.length == 0)) {            /** 平局 **/            this.upScore(p0.uid, p1.uid, 0);            return true;        }        if (p0.chess.length == 0) {            this.winner = p1.uid;            this.upScore(p1.uid, p0.uid, this.ante);            return true;        }        if (p1.chess.length == 0) {            this.winner = p0.uid;            this.upScore(p0.uid, p1.uid, this.ante);            return true;        }        if (this.maxTurn > 12) {            this.sendAll('zhuiqi', {v: 1});            setTimeout(() => {                this.upScore(p0.uid, p1.uid, 0);            }, 2000);            return true;        }        if (!this.needCheckTurn && (p0.chess.length == 1 || p1.chess.length == 1)) {            this.needCheckTurn = true;            this.sendAll('zhuiqi', {v: 0});        }        return false;    }    /**     * 上传分数     * @param winuid     * @param loseuid     * @param score     */    async upScore(winuid, loseuid, score) {        if (this._upscoreed) {            return;        }        this._upscoreed = true;        this.player(winuid).score += score;        this.player(loseuid).score -= score;        this.sendAll('whoWin', {uid: this.winner});        //上传分数        let actualScores = await this.pushScore();        //玩家总分数        this.sendAll("gameResult", actualScores);        //等待前端播放完结果动画，在结束本小局        this.setTimeout(() => {            this.end();        }, 1000);    }    /**     * 回放战绩     */    getPlayback() {        let data = {actlist: this.actlist};        return data;    }    /**     * 游戏信息     */    getInfo(uid) {        uid = parseInt(uid);        let maxTimeout = !!this.cid ? 30000 : 90000;        let msg = {            turn: this.turnUid,            auto: maxTimeout-(Date.now()-this.operatTime), //剩下的操作时间            uids: this.uids,            chess: this.curChess,            types: {}        };        this.players.forEach(function (el) {            msg.types[el.uid] = el.type;        }, this);        this.send(uid, "gameInfo", msg);    }    /**     * 释放类     */    onDestroy() {        super.onDestroy();    }}module.exports = Main;