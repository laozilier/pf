/** * * 大小顺序 * 0点-9.5点: 0-9.5 * 二八杠: 80  倍数: 2 * 豹子: 90  倍数: 3 * 红中对: 100  倍数: 5 * * * * * 返回结果 * { *  type:10,        代表类型 *  value: 1876,    代表大小 *  mul: 2          代表倍数 * } * * Created by apple on 2017/9/29. */module.exports = {    getAllCards: function () {        let cards = [];        for (let i = 21; i < 30; i++) {            for (let j = 0; j < 4; j++) {                cards.push(i);            }        }        for (let i = 0; i < 4; i++) {            cards.push(35)        }        return cards;    },    /**     * 获取结果     * @param cards 牌     * @param rule 规则信息     * @return {Object}     */    getResult:function (cards, rule) {        let holds = cards.concat();        holds.sort(function (a, b) {            return b - a;        });        if (rule.playMode == 1) {            /** 湖南玩法 红中对最大 **/            if (holds[0] == 35 && holds[1] == 35) {                let type = 22;                return {type: type, value: 100*1000, mul: 5};            }            /** 二八杠 **/            if (holds[0] == 28 && holds[1] == 22) {                let type = 21;                return {type: type, value: 90*1000, mul: 3};            }            /** 豹子 **/            if (holds[0] == holds[1]) {                let type = 20;                return {type: type, value: 80*1000+holds[0]%10, mul: 2};            }        } else if (rule.playMode == 2) {            /** 东北玩法 二八杠最大 **/            if (holds[0] == 28 && holds[1] == 22) {                let type = 21;                return {type: type, value: 100*1000, mul: 5};            }            /** 红中对 **/            if (holds[0] == 35 && holds[1] == 35) {                let type = 22;                return {type: type, value: 90*1000, mul: 3};            }            /** 豹子 **/            if (holds[0] == holds[1]) {                let type = 20;                return {type: type, value: 80*1000+holds[0]%10, mul: 2};            }        } else {            /** 通用玩法 红中对最大 **/            if (holds[0] == 35 && holds[1] == 35) {                let type = 22;                return {type: type, value: 100*1000, mul: 5};            }            /** 豹子 **/            if (holds[0] == holds[1]) {                let type = 20;                return {type: type, value: 90*1000+holds[0]%10, mul: 3};            }            /** 二八杠 **/            if (holds[0] == 28 && holds[1] == 22) {                let type = 21;                return {type: type, value: 80*1000, mul: 2};            }        }        /** 普通点数 **/        let mul = 1;        let point = 0;        let value = 0;        for (let i = 0; i < holds.length; i++) {            let card = holds[i];            if (card == 35) {                point+=0.5;                value+=0.5;            } else {                point+=(card%20);                value+=point*(i == 0 ? 10 : 1);            }        }        let type = point%10;        if (!!rule.ba_fan && type >= 8) {            mul = 2;        }        return {type: type*2, value: type*1000+value, mul: mul};    },    /**     * 发牌     * @param count 发几手牌     * @param rule  规则     * @param {Array} [cards]  一副牌     * @return {Object}     */    deal:function (count, rule, cards) {        //保存实际要发到玩家手上的牌        let holds = [];        // let max = 10;        let max = count;        //发十手牌到这个数组，会从中间抽掉多余的牌        let allHolds = [];        for (let i=0; i<max; i++) {            allHolds.push([[], {}]);        }        // let allHolds = [[[], {}], [[], {}], [[], {}], [[], {}], [[], {}], [[], {}], [[], {}], [[], {}], [[], {}], [[], {}]];        let isShuffled = false;        if (!cards) {            isShuffled = true;            cards = this.getAllCards();        }        for (let i = 0; i < cards.length; ++i){            let i = parseInt(Math.random() * cards.length);            let j = parseInt(Math.random() * cards.length);            let n = cards[i];            cards[i] = cards[j];            cards[j] = n;        }        //发牌, 一人一张发两轮        let idx = 0;        for(; idx < cards.length; ++idx){            if(idx < max * 2){                let seat = idx%max;                allHolds[seat][0].push(cards[idx]);            } else {                break;            }        }        let testHolds = [            [[35, 35], {}],            [[22, 28], {}],            [[21, 21], {}],            [[24, 24], {}],            [[28, 22], {}],            [[25, 25], {}],            [[23, 26], {}],            [[23, 26], {}],            [[23, 25], {}]        ];        // allHolds = testHolds.slice(0, count);        //抽掉多余的牌        for(let i = 0; i < count; ++i){            let randomId = Math.randomRange(0, allHolds.length);            let hold = allHolds.splice(randomId, 1)[0];            holds.push(hold);        }        //计算结果        for(let i = 0; i < count; ++i){            let arr = holds[i][0];            holds[i][1] = this.getResult(arr, rule);        }        let leftCards = cards.slice(idx);        return {            holds: holds,            leftCards: leftCards,            isShuffled: isShuffled        };    },    /**     * 比较两手牌大小，左>=右 = true     * @param left     * @param right     * @returns {Boolean}     */    compareHolds: function(left, right){        return left.value >= right.value;    },};