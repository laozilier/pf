/** * Created by apple on 2017/11/1. */let BasePlayer = require('../BasePlayer');const Status = require('../Status').ttz;class Player extends BasePlayer{    constructor(main, uid){        super(main);        this.uid = uid;        this.holds = new Array(5);  //手持的牌        this.holdsValue = {};       //手上牌的值        this.bet = 0;               //下注数量        this.bet1 = 0;        this.bet2 = 0;        this.score = 0;             //分数        this.isBet1 = false;        this.isBet2 = false;        this.isGiveUp = false;      //是否弃牌        this.timeoutId = -1;        this.initEvent();    }    initEvent(){        this.on('bet', this.setBet);        this.on('giveup', this.giveup);    }    /**     * 设置托管状态     * @param has     */    setTrusteeship(has) {        this.isTrusteeship = has;        // 如果进入托管状态，则判断这一把是否需要自动操作        if(has){            switch (this._main.status){                case Status.WAIT_BETS_1:                    if(!this.isBet1){                        this.setBet(this.main.bets1[0]);                    }                    break;                case Status.WAIT_BETS_2:                    if(!this.isBet2){                        // this.setBet2(0);                        this.setBet(this.main.bets2[0]);                    }                    break;            }        }    }    /**     * 发送给自己     */    getInfo(){        let data = {            holds : [],            isTrusteeship: false,            isGiveUp: this.isGiveUp,            bet: this.bet,            // bet1: this.bet1,            // bet2: this.bet2,            isBet1: this.isBet1,            isBet2: this.isBet2        };        switch (this._main.status) {            case Status.WAIT_BETS_1:                data.holds = this.holds.slice(0, 1);                break;            case Status.WAIT_BETS_2:            case Status.BI_PAI:                data.holds = this.holds;                // data.holdsValue = this.holdsValue;                // data.type = this.holdsValue.type;                break;        }        return data;    }    /**     * 发送给其它玩家的信息     */    getOtherInfo(){        let data = {            isTrusteeship: false,            isGiveUp: this.isGiveUp,            bet: this.bet,            isBet1: this.isBet1,            isBet2: this.isBet2,        };        switch (this._main.status) {            case Status.WAIT_BETS_1:                data.holds = [0];                break;            case Status.WAIT_BETS_2:                data.holds = this.holds.slice(0, 1); //闲家注数                data.holds.push(0);                break;            case Status.BI_PAI:            case Status.END:                data.holds = this.holds; //牌                data.holdsValue = this.holdsValue;  //结果                data.type = this.holdsValue.type;                break;        }        return data;    }    /**     * 放弃     */    giveup() {        if (this.isGiveUp) {            console.log(`<giveup> 您已经放弃，请勿重复操作！`);            return;        }        if (!this.main.isStatus(Status.WAIT_BETS_1) && !this.main.isStatus(Status.WAIT_BETS_2)) {            console.log(`<giveup> 游戏当前处于${this.main.status}状态，不能放弃`);            return;        }        if (this.main.isStatus(Status.WAIT_BETS_1) && this.isBet1) {            console.log(`<giveup> 一轮已经下注的不能放弃`);            return;        }        if (this.main.isStatus(Status.WAIT_BETS_2) && this.isBet2) {            console.log(`<giveup> 二轮已经下注的不能放弃`);            return;        }        this.isGiveUp = true;        this.sendAll('giveup', {            uid: this.uid        });        this.main.nextStage();    }    /**     * 第一次下注     * @param id     */    setBet(coins) {        if (!this.main.isStatus(Status.WAIT_BETS_1) && !this.main.isStatus(Status.WAIT_BETS_2)) {            console.log(`<setBet> 当前不是下注状态, status: ${this.main.status}`);            return;        }        if (this.isBet1 && this.main.isStatus(Status.WAIT_BETS_1)) {            console.log(`<setBet> 第一轮已下注，请勿重复下注`);            return;        }        if (this.isBet2 && this.main.isStatus(Status.WAIT_BETS_2)) {            console.log(`<setBet> 第二轮已下注，请勿重复下注`);            return;        }        if (this.isGiveUp) {            console.log(`<setBet> 已放弃不能再下注`);            return;        }        coins = parseInt(coins);        if (isNaN(coins)) {            console.log(`<setBet1> 参数错误，coins: ${coins}`);            return;        }        if (this.main.isStatus(Status.WAIT_BETS_1)) {            if (this.main.bets1.indexOf(coins) == -1) {                console.log(`<setBet1> 参数错误，coins: ${coins} 不在列表${this.main.bets1}中`);                return;            }            this.isBet1 = true;            this.bet1 = coins;        }        if (this.main.isStatus(Status.WAIT_BETS_2)) {            if (this.main.bets2.indexOf(coins) == -1) {                console.log(`<setBet2> 参数错误，coins: ${coins} 不在列表${this.main.bets2}中`);                return;            }            this.isBet2 = true;            this.bet2 = coins;        }        this.bet += coins;        this.sendAll('xiazhu', {uid: this.uid, bet: this.bet, currbet: coins});        this._main.nextStage();    }    /**     * 发送第一张张牌给前端     */    sendHolds1(){        let obj = {};        obj[this.uid] = this.holds.slice(0,1);        for (let p of this.main.players) {            if (p.uid != this.uid) {                obj[p.uid] = [0];            }        }        this.send('holds1', obj);    }    /**     * 发送最后一张牌给前端     */    sendHolds2(){        let obj = {};        obj[this.uid] = this.holds;        for (let p of this.main.players) {            if (p.uid != this.uid) {                obj[p.uid] = [p.holds[0], 0];            }        }        this.send('holds2', obj);    }    /**     * 推送下注列表     */    sendStartBets(){        this.send("startBet", {bets:this.anteList, uid:this._main.zuid});    }}module.exports = Player;