/** * Created by apple on 2017/11/1. */let BaseMain = require('../BaseMain');let Player = require('./Player');let alg = require('./algorithm');const aliasMethod = require('../../../../../common/aliasMethod');const Status = require('../Status').ttz;const autoTimes = require('../Status').ttzAutoTimes;const gameConfig = require('./config');/** *  规则信息 account:cc.user.account, //账号 sign:cc.user.sign,       //sign证验码 uid:cc.user.uid, game_type:0, max:0,        //最大局数 halfway:true, //是否中途加入 game_rule:{                difen:0,        底分 id            } */class Main extends BaseMain {    /**     *     * @param uids  玩家uid列表     * @param rule  游戏规则     */    constructor(uids, rule, room) {        super(room);        /**         * @type {[]}         * */        this.players = []; //玩家对象        this.rule = rule; //游戏规则        this.zmode = rule.zmode;        this.zuid = null; //庄家uid        this.uids = uids; //玩家uid列表        this.ante = rule.ante || 5000;        this.endStatus = 0; // 0 未结束， 1 正常结束，2流局        //下注底分        // this.bets = [1, 2, 4, 8];        this.bets1 = [5];        this.bets2 = [10];        if (!isNaN(rule.ante)) {            // this.bets = [            //     parseInt(rule.ante),            //     parseInt(rule.ante) * 2,            //     parseInt(rule.ante) * 4,            //     parseInt(rule.ante) * 8            // ]            this.bets1 = this.bets1.map((b) => parseInt(rule.ante) * b);            this.bets2 = this.bets2.map((b) => parseInt(rule.ante) * b);        }        this.status = Status.BEGIN;// 1.等待下注状态; 2.等待搓牌状态; 3等待抢庄状态        this.bipai = null;        this.gameResult = null;        this.cards = this.getLasting().cards;        //发牌        let cardsObj = alg.deal(uids.length, rule, this.cards);        let holdsList = cardsObj.holds;        this.getLasting().cards = cardsObj.isShuffled ? cardsObj.leftCards : null;        /** 是否重新洗牌了 */        this.isShuffled = cardsObj.isShuffled;        //创建玩家        for (let i = 0; i < uids.length; ++i) {            let play = new Player(this, uids[i]);            // play.anteList = this.bets.slice(0, this.bets.length); //保存下注列表            play.isTrusteeship = room.player(uids[i]).isTrusteeship; //托管状态            this.players.push(play);  //把玩家保存到这个数组        }        /**根据大小排序*/        holdsList.sort((a, b) => {            return alg.compareHolds(a[1], b[1]) ? 0 : 1;        });        this.deal(holdsList);    }    deal(holdsList){        let negativeAlias = []; //负幸运的玩家        let alias = [];         //幸运玩家        let robotAlias = [];    //        let normal = [];        //正常玩家        this.players.forEach(player => {            if(player.getRobot()){                robotAlias.push(player);            } else if(player.getLucky() > 0){                alias.push(player);            } else if(player.getLucky() < 0){                negativeAlias.push(player);            } else {                normal.push(player);            }        });        //给负幸运玩家排序        negativeAlias.sort((a, b) => {            return a.getLucky() - b.getLucky();        });        //给正幸运玩家排序        alias.sort((a, b) => {            return b.getLucky() - a.getLucky();        });        //把玩家连接起来,拿牌顺序先负在正在机在普        let tempPlayers = negativeAlias.concat(alias).concat(robotAlias).concat(normal);        let length = tempPlayers.length;        tempPlayers.forEach((player, i) => {            let random = Math.randomRange(0, holdsList.length);            if (length - i > 1) { //玩家数大于1才能使用概率                if (player.getRobot()) { //机器人概率                    alias = gameConfig.robotAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if(player.getLucky() > 0){ //幸运概率                    alias = gameConfig.alias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if(player.getLucky() < 0){ //负幸运概率                    alias = gameConfig.negativeAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                }            }            let holds = holdsList.splice(random, 1)[0];            player.holds = holds[0];      //设置牌            player.holdsValue = holds[1]; //设置值        });    }    /**     * 判断当前状态     * @param s     * @return {boolean}     */    isStatus(s) {        return (parseInt(s) === this.status);    }    /**     * 计时器     * @param cb     */    schedule(cb) {        this.clearTimeout(this.timeoutId);        this.optEndTime = Date.now() + (autoTimes[this.status] * 1000);        let times = (autoTimes[this.status] * 1000);        this.timeoutId = this.setTimeout(cb, times);    }    player(uid) {        for (let i = 0; i < this.players.length; ++i) {            if (this.players[i].uid === parseInt(uid)) {                return this.players[i];            }        }        return null;    }    /**     * 获取这一状态还剩多少时间     */    getSurplusTime() {        let t = this.optEndTime - Date.now();        return t > 0 ? t : 0;    }    /**     * 改变状态     * @param code 状态码     */    changeStatus(code) {        //设置状态        this.status = code;        this.sendAll("gameStatus", {status: code});        switch (code) {            case Status.WAIT_BETS_1:                for (let p of this.players) {                    if (!p.isGiveUp) {                        p.send('betList', this.bets1);                    }                }                //一定时间后所有玩家自动放弃                this.schedule(() => {                    this.players.forEach((el) => {                        if (!el.isBet1) {                            el.giveup();                        }                        // el.setBet(this.bets1[0]);                    });                });                //自动操作托管玩家                this.setTimeout(() => {                    this.players.forEach((el) => {                        if (el.isTrusteeship && !el.isBet1) {                            el.giveup();                            // el.setBet(this.bets1[0]);                        }                    }, this);                }, 1000);                break;            case Status.WAIT_BETS_2:                for (let p of this.players) {                    if (!p.isGiveUp) {                        p.send('betList', this.bets2);                    }                }                //一定时间后所有玩家自动放弃                this.schedule(() => {                    this.players.forEach((el) => {                        if (!el.isBet2) {                            el.giveup();                        }                        // el.setBet(this.bets2[0]);                    });                });                //自动操作托管玩家                this.setTimeout(() => {                    this.players.forEach((el) => {                        if (el.isTrusteeship && !el.isBet2) {                            el.giveup();                            // el.setBet(this.bets2[0]);                        }                    }, this);                }, 1000);                break;            case Status.BI_PAI:                let players = this.players.concat();                players.sort((a, b) => {                    return a.holdsValue.value - b.holdsValue.value;                });                let bipaiList = [];                let timespan = 0;                let hasGiveUp = false;                for (let p of players) {                    if (p.isGiveUp) {                        // hasGiveUp = true;                    } else {                        timespan += 1000;                    }                    let obj = {                        uid: p.uid,                        holds: p.holds,                        type: p.holdsValue.type,                        isGiveUp: p.isGiveUp                    };                    bipaiList.push(obj);                }                this.bipai = bipaiList;                this.sendAll('bipai', bipaiList);                // todo: 预计结束时间                // let timespan = bipaiList.length * 1000 + 1500;                timespan += 2500;                // if (hasGiveUp) {                //     timespan += 1000;                // }                this.setTimeout(this.doGameOver, timespan);                break;        }    }    /**     * 游戏开始的接口     */    begin() {        let dice = [];        do {            dice = [];            for (let i = 0; i < 2; i++) {                dice.push(Math.ceil(Math.random() * 6));            }        } while (!this.isShuffled && (dice[0] + dice[1]) >= this.cards.length / 2);        this.sendAll("gameBegin", {            ante: this.ante,            uids: this.uids,            dice: dice,            isShuffled: this.isShuffled,            numCards: this.cards ? this.cards.length : 40,            trends: this.getLasting().trends,            leftCards: this.getLeftCards()        });        let obj = {};        this.players.forEach((p) => {            p.bet = this.ante;            obj[p.uid] = p.bet;        });        //发送游戏开始        setTimeout(() => {            this.sendAll('bet', obj);        }, 4500);        setTimeout(() =>{            //每人先发一张牌            this.players.forEach((el) => {                //发送托管情况                this.sendAll(Event.tuoGuang, [el.uid, el.isTrusteeship]);                el.sendHolds1();            });            /** 通知所有人发牌(背牌) **/            this.sendAll("deal", {num: 1, index: this.getLasting().cardsIndex});            this.getLasting().cardsIndex += this.uids.length;            // this.changeStatus(Status.WAIT_BETS_1);        }, 6000);        this.status = Status.WAIT_BETS_1;        setTimeout(() => {            this.changeStatus(Status.WAIT_BETS_1);        }, 8500);    }    nextStage() {        // todo: 统计放弃的玩家数目，和已跟注的玩家的数目，        // todo: 1. 所有玩家都已经放弃，则为流局，流局都不输钱        // todo: 2. 已经放弃的玩家的数目和已跟注的玩家的数目之和等于所有的玩家数，则进入下一游戏阶段        let numGiveUp = 0;        let numBet = 0;        for (let i = 0; i < this.players.length; ++i) {            if (this.players[i].isGiveUp) {                numGiveUp++;            } else {                if (this.isStatus(Status.WAIT_BETS_1) && this.players[i].isBet1) {                    numBet++;                }                if (this.isStatus(Status.WAIT_BETS_2) && this.players[i].isBet2) {                    numBet++;                }            }        }        console.log(`<nextStage> numGiveUp: ${numGiveUp}, numBet: ${numBet}, numPlayers: ${this.uids.length}`);        let timespan = 0;        if (numGiveUp == this.uids.length) {            // 流局            this.endStatus = 2;        } else if (this.uids.length == numGiveUp + numBet) {            if (numBet == 1) {                // 正常结束                this.endStatus = 1;            }        }        if ((this.endStatus || (this.uids.length == numGiveUp + numBet)) && this.isStatus(Status.WAIT_BETS_1)) {            if (this.isStatus(Status.WAIT_BETS_1)) {                // return this.bet1End();                timespan = 2000;                // 在第一轮所有人都放弃了                this.players.forEach((p) => {                    p.sendHolds2();                });                let guestHolds = {};                for (let p of this.players) {                    guestHolds[p.uid] = p.holds.slice(0, 1);                    guestHolds[p.uid].push(0);                }                this.sendAll('deal', {num: 2, index: this.getLasting().cardsIndex, holds: guestHolds});                this.getLasting().cardsIndex += this.uids.length;            }        }        if (this.endStatus) {            this.status = Status.BI_PAI;            this.clearTimeout(this.timeoutId);            setTimeout(() => {                this.changeStatus(Status.BI_PAI);            }, timespan);        } else if (this.uids.length == numGiveUp + numBet) {            // 下一阶段            if (this.isStatus(Status.WAIT_BETS_1)) {                this.status = Status.WAIT_BETS_2;                this.clearTimeout(this.timeoutId);                return setTimeout(() => {                    this.changeStatus(Status.WAIT_BETS_2);                }, 2500);            }            if (this.isStatus(Status.WAIT_BETS_2)) {                this.status = Status.BI_PAI;                this.clearTimeout(this.timeoutId);                return setTimeout(() => {                    this.changeStatus(Status.BI_PAI);                }, 2000);            }        }    }    doGameOver() {        //计算结果        this.countResult();        if (!this.isShuffled) {            this.getLasting().cardsIndex = 0;        }        //把推注数据挂到持久层        // if (this.zmode == 0) {        //     this.getLasting().nextZUids = [];        //     let idx = this.uids.indexOf(this.zuid);        //     for (let i = idx+1; i < this.uids.length; i++) {        //         this.getLasting().nextZUids.push(this.uids[i]);        //     }        //        //     for (let i = 0; i < idx; i++) {        //         this.getLasting().nextZUids.push(this.uids[i]);        //     }        // }        //上传分数        let actualScores = this.pushScore();        let allHolds = {};        let allBets = {};        let otherCards = null;        if (!this.isShuffled) {            otherCards = this.getLeftCards();            let noCardsLeft = true;            for (let c in otherCards) {                if (otherCards[c] > 0) {                    noCardsLeft = false;                    break;                }            }            if (noCardsLeft) {                otherCards = null;            }        }        for (let p of this.players) {            allHolds[p.uid] = {                holds: p.holds,                holdsValue: p.holdsValue            };            allBets[p.uid] = p.bet;            if (otherCards) {                for (let c of p.holds) {                    if (otherCards[c] > 0) {                        otherCards[c]--;                    }                }            }        };        // delete actualScores[this.zuid];        //玩家总分数        this.gameResult = {            allScores: actualScores,            allHolds: allHolds,            allBets: allBets,            otherCards: otherCards            // todo: 返回剩余牌        };        this.sendAll("gameResult", this.gameResult);        //等待前端播放完结果动画，在结束本小局        this.setTimeout(() => {            this.end();        }, 3000);    }    /**     * 计算结果     */    countResult() {        // 流局所有人的得分都是0        let players = this.players.concat();        players.sort((a, b) => b.holdsValue.value - a.holdsValue.value);        let winList = [];        let winUids = [];        let seatIdPlayerMap = {};// 房间层座位号        let winner = null;        let coinsTotal = 0;        for (let p of players) {            if (!winner) {                if (!p.isGiveUp) {                    winner = p;                    winList.push(p);                    winUids.push(p.uid);                }            } else if (!p.isGiveUp && p.holdsValue.value == winner.holdsValue.value) {                winList.push(p);                winUids.push(p.uid);            }            if (this.endStatus != 2 && winUids.indexOf(p.uid) == -1) {                coinsTotal += p.bet;                p.score -= p.bet;            }            seatIdPlayerMap[this.room.player(p.uid).seatId] = p;        }        for (let w of winList) {            w.score += Math.floor(coinsTotal / winList.length);        }        let trends = this.getLasting().trends;        for (let i = 0; i < trends.length; i++) {            let trend = trends[i];            if (Reflect.has(seatIdPlayerMap, i.toString())) {                if (this.endStatus != 2) {                    if (seatIdPlayerMap[i].score >= 0) {                        trend.unshift(1);                    } else {                        trend.unshift(0);                    }                } else {                    trend.unshift(2);                }            } else {                // todo: 没打暂不记录            }            if (trend.length > 15) {                trend.pop();            }        }    }    getLeftCards() {        let allCards = this.cards;        if (!allCards) {            allCards = alg.getAllCards();        } else {            allCards = allCards.concat();        }        let leftCards = {};        let cardVals = [21, 22, 23, 24, 25, 26, 27, 28, 29, 35];        for (let v of cardVals) {            leftCards[v] = 0;        }        for (let c of allCards) {            leftCards[c]++;        }        return leftCards;    }    /**     * 回放战绩     */    getPlayback() {        let data = {};        this.players.forEach((el) => {            //要保存的历史记录            data[el.uid] = {                holds: el.holds,                holdsValue: el.holdsValue, //点数                score: el.score,                bet: el.bet,                isGiveUp: el.isGiveUp            };        });        return data;    }    /**     * 根据牛的类型计算分数     * @param {Object} type   牛类型     * @param ante    底注     * @returns {number} 计算完的分数     */    getScore(mul, ante) {        return mul * ante * this.maxRob;    }    /**     * 游戏信息     */    getInfo(uid) {        uid = parseInt(uid);        let msg = {            zuid: this.zuid,            status: this.status,            surplusTime: this.getSurplusTime(), //这一状态剩下的时间            uids: this.uids,            trends: this.getLasting().trends,            leftCards: this.getLeftCards(),            bipai: this.bipai,            gameResult: this.gameResult,            // numCards: this.cards ? this.cards.length : 40,            numCards: 40 -  this.getLasting().cardsIndex,            index: this.getLasting().cardsIndex,            players: {}        };        switch (this.status) {            case Status.WAIT_BETS_1:                // msg.numCards -= this.uids.length;                msg.betList = this.bets1;                break;            case Status.WAIT_BETS_2:                // msg.numCards -= 2 * this.uids.length;                msg.betList = this.bets2;                break;            // case Status.BI_PAI:            //     msg.numCards -= 2 * this.uids.length;            //     break;            // case Status.END:            //     msg.numCards -= 2 * this.uids.length;            //     break;        }        this.players.forEach(function (el) {            if (uid === el.uid) {                msg.players[el.uid] = el.getInfo();            } else {                msg.players[el.uid] = el.getOtherInfo();            }        }, this);        this.send(uid, "gameInfo", msg);    }    /**     * 释放类     */    onDestroy() {        super.onDestroy();    }}module.exports = Main;