/** * Created by apple on 2017/11/1. */let BaseMain = require('../BaseMain');let Player = require('./Player');let alg = require('../棋牌算法/pszAlgorithm');const aliasMethod = require('../../../../../common/aliasMethod');const Status = require('../Status').jinhua;const gameConfig = require('./config');/** *  规则信息 account:cc.user.account, //账号 sign:cc.user.sign,       //sign证验码 uid:cc.user.uid, game_type:0, max:0,        //最大局数 halfway:true, //是否中途加入 game_rule:{                difen:0,        底分 id                tuizhu:0,       推注 id                multiple:0,     倍数 id  抢庄倍数                multipleRule:0, 翻倍规则                dScore:0,       庄家                isCp:false,     是否搓 牌                isWhn:false,    是否五小牛                isZdn:false,    是否炸弹牛                isWxn:false,    五花牛                isHln:false,    葫芦牛                isThn:false,    同花牛                isSn:false      顺子牛            } */class Main extends BaseMain {    /**     *     * @param uids  玩家uid列表     * @param rule  游戏规则     */    constructor(uids, rule, room) {        super(room);        /**         * @type {[]}         * */        this.players = []; //玩家对象        this.rule = rule; //游戏规则        this.zuid = null; //发话玩家uid        this.uids = uids; //玩家uid列表        // 游戏结束的时候保存winner        // this.latestWinner = this.getLasting().winner; // 上局赢家        this.turn = -1;        this.hasXi = true;        this.ante = rule.ante || 5000;        this.mustMen = rule.mustMen || 0; // 必焖几轮        this.multiList = rule.multiList || [1, 2, 4, 6];        // this.maxMulti = rule.maxMulti || 4; // 最大翻倍数        this.coinPool = 0; // 金币池金额        this.maxRound = rule.maxRound || 7;        this.currRound = 1; // 第几轮跟随        this.currMulti = this.multiList[0]; // 当前倍数(焖)        this.algRule = {            flushBTAbc: rule.hasOwnProperty('flushBTAbc') ? rule.flushBTAbc : true // 金花大于顺子        };        this.currentAction = null;// 当前操作        this.status = Status.BEGIN;// 1.等待下注状态; 2.等待搓牌状态; 3等待抢庄状态        //发牌        let cardsObj = alg.deal(uids.length, this.algRule);        let holdsList = cardsObj.holds;        // let uidObj = [];        //创建玩家        for (let i = 0; i < uids.length; ++i) {            let play = new Player(this, uids[i]);            // play.anteList = this.bets.slice(0, this.bets.length); //保存下注列表            play.isTrusteeship = room.player(uids[i]).isTrusteeship; //托管状态            if (this.mustMen) {                play.canWaiver = false;                play.canCompare = false;                play.canOpenCards = false;            }            this.players.push(play);  //把玩家保存到这个数组            // uidObj.push(play); //用来发牌排序        }        this.deal(holdsList);    }    deal(holdsList){        let negativeAlias = []; //负幸运的玩家        let alias = [];         //幸运玩家        let robotAlias = [];    //        let normal = [];        //正常玩家        this.players.forEach(player => {            if(player.getRobot()){                robotAlias.push(player);            } else if(player.getLucky() > 0){                alias.push(player);            } else if(player.getLucky() < 0){                negativeAlias.push(player);            } else {                normal.push(player);            }        });        //给负幸运玩家排序        negativeAlias.sort((a, b) => {            return a.getLucky() - b.getLucky();        });        //给正幸运玩家排序        alias.sort((a, b) => {            return b.getLucky() - a.getLucky();        });        //把玩家连接起来,拿牌顺序先负在正在机在普        let tempPlayers = negativeAlias.concat(alias).concat(robotAlias).concat(normal);        let length = tempPlayers.length;        tempPlayers.forEach((player, i) => {            let random = Math.randomRange(0, holdsList.length);            if (length - i > 1) { //玩家数大于1才能使用概率                if (player.getRobot()) { //机器人概率                    alias = gameConfig.robotAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if(player.getLucky() > 0){ //幸运概率                    alias = gameConfig.alias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if(player.getLucky() < 0){ //负幸运概率                    alias = gameConfig.negativeAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                }            }            let holds = holdsList.splice(random, 1)[0];            player.holds = holds.cards;            player.checkPattern = holds.pattern;        });    }    /**     * 游戏开始的接口     */    begin() {        let latestWinnerSeatIndex = this.uids.indexOf(this.getLasting().winner);        if (latestWinnerSeatIndex > -1) {            this.turn = ++latestWinnerSeatIndex % this.uids.length;        } else {            this.turn = Math.floor(Math.random() * this.uids.length);        }        this.zuid = this.uids[this.turn];        this.sendAll("gameBegin", {uids: this.uids, zuid: this.zuid}); //发送游戏开始        this.status = Status.INGAME;        this.sendAll("gameStatus", {status: this.status});        this.players.forEach((el) => {            // 所有玩家打底            el.follow(this.currMulti, true);        });        // 发背牌        setTimeout(() => {            this.sendAll("deal", {num: 3});        }, 1000);        setTimeout(() => {            this.nextTurn();        }, 2000);    }    /**     * 判断当前状态     * @param s     * @return {boolean}     */    isStatus(s) {        return (parseInt(s) === this.status);    }    player(uid) {        for (let i = 0; i < this.players.length; ++i) {            if (this.players[i].uid === parseInt(uid)) {                return this.players[i];            }        }        return null;    }    isGameOver() {        let numLeft = 0;        for (let p of this.players) {            if (!p.isWaiver) {                numLeft++;            }        }        if (this.isStatus(Status.INGAME) && numLeft === 1) {            return true;        }        return false;    }    /**     * 移到下一家操作     */    nextTurn() {        console.log("current turn: " + this.turn);        // 判断是否可以结束游戏了        // 弃牌之后如果只剩下一个人，则进入结算        // 比牌时如果只剩下两个人，比完之后进入结算        if (this.isGameOver()) {            return this.doGameOver();        }        // let currentAction = {        //     uid: '888',        //     action: 0, // 0 弃权，1: 打底，2 跟注，3 加注，4 看牌，5 比牌，6 孤注一掷        //     data: {        //         typeFollow: 1,        //         numFollow: 8000,        //         multi: 1        //     }        // };        if ([1, 4].indexOf(this.currentAction.action) == -1){            do {                this.turn = (++this.turn) % this.uids.length;                let tuid = this.uids[this.turn];                if (tuid == this.zuid) {                    // 新的一轮开始了                    this.currRound++;                }                // 跳过已经弃权的玩家            } while (this.players[this.turn].isWaiver);        }        if (this.currRound >= this.maxRound) {            // todo: 此处可加一条，最后一轮提醒消息            // 取消所有的自动跟            for (let p of this.players) {                p.isAuto = false;                p.canAuto = false;            }        }        if (this.currRound > this.mustMen) {            for (let p of this.players) {                if (!p.isWaiver) {                    p.canWaiver = true;                }                p.canCompare = true;                if (!p.isOpenedCards && !p.isWaiver) {                    p.canOpenCards = true;                }            }        }        let timeSpan = 0;        if (this.currentAction && [5, 6].indexOf(this.currentAction.action) > -1) {            // timeSpan = 2000;            timeSpan = 3300;        }        setTimeout(() => {            this.changedTurn(this.uids[this.turn]);        }, timeSpan);    }    /**     * 修改出牌玩家     * @param uid     */    changedTurn(uid) {        console.log(`${uid} 进来操作！`);        // todo: 当轮到玩家时，倒计时一到，玩家没有做出决策，则进入托管状态        // this.startTimeout(uid);        // todo: 带上玩家当前的可操作选项，和可加注的倍数（哪些可用，哪些不可用）        let player = this.player(uid);        let actions = player.getActions();        // todo: 如果要自动孤注一掷，在这里判断玩家是否能孤注一掷，如果能，直接孤注一掷结算也走follow        let turnData = {            uid: uid,            surplusTime: this.getSurplusTime(),            currRound: this.currRound,            currMulti: this.currMulti, // 焖翻倍列表            currFollow: this.ante * this.currMulti,            [uid]: actions        };        for (let p of this.players) {            if (!Reflect.has(turnData, p.uid)) {                turnData[p.uid] = {                    canAuto: p.canAuto,                    isAuto: p.isAuto,                    canWaiver: p.canWaiver,                    canOpenCards: p.canOpenCards,                    canFollow: false,                    canMulti: false,                    canCompare: false,                    compareUids: []                }            }        }        this.startTimeout(uid);        turnData.surplusTime = this.getSurplusTime();        this.sendAll("turn", turnData);    }    /**     * 启动托管计时器     * @param uid     */    startTimeout (uid) {        this.clearTimeout(this.operatTimeoutId); //清空上一个计时器        this.operatTime = Date.now(); //操作开始时间        //倒计时id,如果在指定时间内没有出牌，则系统自动出牌        let player = this.player(uid);        let timeout = 15000;        if (this.ante >= 10000) {            timeout = 20000;        }        //如果玩家已经托管，则只需等待1.5秒时间        if (player.isAuto && player.canFollow) {            timeout = 500;        }        // todo: 记录下timeout时间后的时间，断线重连的时候把剩余的时间返回去        this.optEndTime = Date.now() + timeout;        this.operatTimeoutId = this.setTimeout(() => {            if (player.canWaiver && !player.isAuto) {                player.waiver();            } else {                if (player.canFollow) {                    player.follow(this.currMulti);                } else {                    player.waiver();                }            }        }, timeout);    }    /**     * 获取这一状态还剩多少时间     */    getSurplusTime() {        let t = this.optEndTime - Date.now();        return t > 0 ? t : 0;    }    getPlayerBalance(uid) {        let rp = this.room.player(uid);        return rp.getActualScore();    }    doGameOver() {        this.turn = -1;        this.status = Status.END;        this.sendAll("gameStatus", {status: this.status});        let timespan = 0;        if (this.currentAction && [5, 6].indexOf(this.currentAction.action) > -1) {// 孤注一掷结束游戏也要延时3s            timespan = 4300;            // timespan = 3000;        } else {            timespan = 1000;        }        if (this.hasXi) {            setTimeout(() => {                this.calculateXiScore(0);            }, timespan);        } else {            setTimeout(() => {                this.calculateResult();            }, timespan)        }    }    async calculateXiScore(seatIndex){        if (seatIndex >= this.uids.length) {            return this.calculateResult();        }        let uid = this.uids[seatIndex];        let player = this.player(uid);        if (!player.checkPattern.xi) {            // 没喜，直接下一个            return this.calculateXiScore(++seatIndex);        }        // 有喜        let winObj = {            [player.uid]: player.checkPattern.xi * this.ante * (this.uids.length - 1)        };        let loseObj = {};        for (let p of this.players) {            if (p.uid != player.uid) {                loseObj[p.uid] = player.checkPattern.xi * this.ante            }        }        let xiData = Object.assign({            uid: player.uid, // 谁的喜            xiScoreMap: {} // uid 到本手牌喜分输赢的映射        }, player.checkPattern);        let actual = await this.room.pushHalfwayScore(winObj, loseObj);        xiData.xiScoreMap = actual;        // 发送获得喜的消息        console.log(`<calculateXiScore> xiData: ${JSON.stringify(xiData)}`);        this.sendAll('xi', xiData);        // 有喜，延时计算下一个        return setTimeout(() => {             return this.calculateXiScore(++seatIndex);        }, 2000);    }    async calculateResult() {        let winnerList = [];        let leftPlayers = this.players.filter((p) => !p.isWaiver);        leftPlayers.sort((a, b) => {            b.checkPattern.value - a.checkPattern.value;        });        let winner = leftPlayers[0];        for (let p of leftPlayers) {            if (p.uid != winner.uid && p.checkPattern.value == winner.value) {                winnerList.push(p);            }        }        winnerList.unshift(winner);        if (winnerList.length == 1) {            this.getLasting().winner = winner.uid;            winner.score = this.coinPool - winner.amountFollow;            for (let p of this.players) {                if (p.uid != winner.uid) {                    p.score = -p.amountFollow;                }            }        } else {            this.getLasting().winner = null;            let winTotal = this.coinPool;            for (let w of winnerList) {                winTotal -= w.amountFollow;            }            let winnerScore = Math.floor(winTotal / winnerList.length);            let winuids = [];            for (let win of winnerList) {                winuids.push(win.uid);                win.score = winnerScore;            }            for (let p of this.players) {                if (winuids.indexOf(p.uid) == -1) {                    p.score = -p.amountFollow;                }            }        }        let allScores = await this.pushScore();        let allCards = {}; //剩下的牌        let types = {};        this.players.forEach(el => {            allCards[el.uid] = el.checkPattern.cards;            // allCards[el.uid] = el.checkPattern;            types[el.uid] = el.checkPattern.pattern;        });        this.sendAll("gameResult", {allScores, allCards, amountFollow: winner.amountFollow, types: types});        this.end();    }    /**     * 回放战绩     */    getPlayback() {        let data = {};        this.players.forEach(function (el) {            //要保存的历史记录            data[el.uid] = {                holds: el.holds,                value: el.checkPattern.pattern, //牌型型                score: el.score,                isWaiver: el.isWaiver,                isLoser: el.isLoser            };        }.bind(this));        return data;    }    /**     * 游戏信息     */    getInfo(uid) {        uid = parseInt(uid);        let msg = {            zuid: this.zuid, // 发话玩家uid            status: this.status, // 游戏状态            uids: this.uids, // 所有参与游戏的玩家uid            turn: (this.uids[this.turn] > -1) ? this.uids[this.turn] : -1, // 当前轮转            surplusTime: this.getSurplusTime(),            coinPool: this.coinPool,// 金币池金额            currRound: this.currRound, // 第几轮跟随            currMulti: this.currMulti, // 当前倍数(焖),            currFollow: this.ante * this.currMulti,            currentAction: this.currentAction, //当前操作            players: {}        };        this.players.forEach(function (el) {            if (uid === el.uid) {                msg.players[el.uid] = el.getInfo();            } else {                msg.players[el.uid] = el.getOtherInfo();            }        }, this);        this.send(uid, "gameInfo", msg);    }    /**     * 释放类     */    onDestroy() {        super.onDestroy();    }}module.exports = Main;