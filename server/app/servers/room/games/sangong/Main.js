/** * Created by apple on 2017/11/1. */let BaseMain = require('../BaseMain');let Player = require('./Player');let alg = require('../棋牌算法/3gongAlgorithm');const aliasMethod = require('../../../../../common/aliasMethod');const Status = require('../Status').niuniu;const autoTimes = require('../Status').autoTimes;const gameConfig = require('./config');const Event = require('../niuniu/nnEvent');class Main extends BaseMain {    /**     *     * @param uids  玩家uid列表     * @param rule  游戏规则     */    constructor(uids, rule, room) {        super(room);        /**         * @type {[]}         * */        this.players = []; //玩家对象        this.rule = rule; //游戏规则        this.zuid = null; //庄家uid        this.uids = uids; //玩家uid列表        //下注底分        this.bets = [4, 8];        if (!isNaN(rule.ante)) {            this.bets = [parseInt(rule.ante), parseInt(rule.ante) * 2];        }        // 模式        this.bankerModel = rule.bankerModel || 2; // 0 大混战 1 九点上庄 2 明牌抢庄 3 自由抢庄        // 游戏玩法        this.playMode = rule.playMode || 0; // 0 经典三公模式 1 三公比金花        //推注        this.tuizhu = gameConfig.tuizhus[rule.tuizhu]; //推注倍数        this.tuizhu || (this.tuizhu = gameConfig.tuizhus[0]);        //最大推注分数        this.maxTuiZhu = this.tuizhu === 1 ? 0 : this.tuizhu * this.bets[0]; //最大推注分数        //抢庄倍数        this._robs = gameConfig.multiple[rule.multiple];        this._robs = this._robs || 1;        this.maxRob = 0; //最大抢庄倍数        //下注加倍        this.anteDouble = !!this.rule.anteDouble;        this.status = Status.BEGIN;// 1.等待下注状态; 2.等待搓牌状态; 3等待抢庄状态        //发牌        let cardsObj = alg.deal(uids.length, rule);        let holdsList = cardsObj.holds;        // let uidObj = [];        //创建玩家        for (let i = 0; i < uids.length; ++i) {            let play = new Player(this, uids[i]);            play.anteList = this.bets.slice(0, this.bets.length); //保存下注列表            play.isTrusteeship = room.player(uids[i]).isTrusteeship; //托管状态            this.players.push(play);  //把玩家保存到这个数组            // uidObj.push(play); //用来发牌排序        }        this.deal(holdsList);    }    deal(holdsList){        let negativeAlias = []; //负幸运的玩家        let alias = [];         //幸运玩家        let robotAlias = [];    //        let normal = [];        //正常玩家        this.players.forEach(player => {            if(player.getRobot()){                robotAlias.push(player);            } else if(player.getLucky() > 0){                alias.push(player);            } else if(player.getLucky() < 0){                negativeAlias.push(player);            } else {                normal.push(player);            }        });        //给负幸运玩家排序        negativeAlias.sort((a, b) => {            return a.getLucky() - b.getLucky();        });        //给正幸运玩家排序        alias.sort((a, b) => {            return b.getLucky() - a.getLucky();        });        //把玩家连接起来,拿牌顺序先负在正在机在普        let tempPlayers = negativeAlias.concat(alias).concat(robotAlias).concat(normal);        let length = tempPlayers.length;        tempPlayers.forEach((player, i) => {            let random = Math.randomRange(0, holdsList.length);            if (length - i > 1) { //玩家数大于1才能使用概率                if (player.getRobot()) { //机器人概率                    alias = gameConfig.robotAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if(player.getLucky() > 0){ //幸运概率                    alias = gameConfig.alias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if(player.getLucky() < 0){ //负幸运概率                    alias = gameConfig.negativeAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                }            }            let holds = holdsList.splice(random, 1)[0];            player.holds = holds.cards;            player.checkPattern = holds.sg;            player.jinhuaPattern = holds.jh;            if (player.getRobot()) {                //player.fourCardsValue = player.holdsValue.type;            }        });    }    /**     * 判断当前状态     * @param s     * @return {boolean}     */    isStatus(s) {        return (parseInt(s) === this.status);    }    /**     * 计时器     * @param cb     */    schedule(cb) {        this.clearTimeout(this.timeoutId);        this.optEndTime = Date.now() + (autoTimes[this.status] * 1000);        let times = (autoTimes[this.status] * 1000);        this.timeoutId = this.setTimeout(cb, times);    }    player(uid) {        for (let i = 0; i < this.players.length; ++i) {            if (this.players[i].uid === parseInt(uid)) {                return this.players[i];            }        }        return null;    }    /**     * 获取这一状态还剩多少时间     */    getSurplusTime() {        let t = this.optEndTime - Date.now();        return t > 0 ? t : 0;    }    /**     * 改变状态     * @param code 状态码     */    changeStatus(code) {        //设置状态        this.status = code;        this.sendAll(Event.gameStatus, {status: code});        switch (code) {            case Status.WAIT_ROBS_OPEN:                this.schedule(function () {                    this.players.forEach(function (el) {                        el.setMultiple(0);                    });                });                //自动操作托管玩家                this.setTimeout(() => {                    this.players.forEach((el) => {                        if (el.isTrusteeship) {                            el.setMultiple(0);                        }                    });                }, 1000);                //机器人随机抢庄                this.players.forEach(el => {                    if (el.getRobot()) { //机器人随机时间                        this.setTimeout(() => {                            el.setMultiple(el.fourCardsValue >= 7 ? this._robs : 0);                        }, Math.randomRange(500, 2000));                    }                });                break;            case Status.WAIT_BETS:                //一定时间后所有玩家自动下注                this.schedule(function () {                    this.players.forEach(function (el) {                        el.setBet(0);                    })                });                //自动操作托管玩家                this.setTimeout(() => {                    this.players.forEach((el) => {                        if (el.isTrusteeship) {                            el.setBet(0);                        }                    }, this);                }, 1000);                //机器人随机下注                this.players.forEach(el => {                    if (el.getRobot()) { //机器人随机时间                        this.setTimeout(() => {                            el.setBet(el.fourCardsValue >= 7 ? 1 : 0);                        }, Math.randomRange(500, 3000));                    }                });                break;            case Status.CUOPAI_ONE:                this.schedule(function () {                    this.players.forEach(function (el) {                        el.showHolds();                    })                });                //托管玩家直接亮牌                this.setTimeout(() => {                    this.players.forEach(function (el) {                        if (el.isTrusteeship) {                            el.showHolds();                        }                    });                }, 1000);                //机器人随机亮牌                this.players.forEach(el => {                    if (el.getRobot()) { //机器人随机时间                        this.setTimeout(() => {                            el.showHolds();                        }, Math.randomRange(1000, 3000));                    }                });                break;        }    }    /**     * 游戏开始的接口     */    begin() {        // todo: 有庄模式才可以推注        //可推注玩家列表        let tuizhuList = [];        //计算推注分数        if (Object.keys(this.room.sd).length > 0) {            //推注分数            if (this.tuizhu > 1) {                for (let uid in this.room.sd.players) {                    //上一把赢的分数                    let s = this.room.sd.players[uid].score || 0;                    if (parseInt(s) > 0) {                        let player = this.player(uid);                        if (player) {                            player.anteList.push(parseInt(s));                            player.canTuizhu = true;                            tuizhuList.push(parseInt(uid));                        }                    }                }            }        }        //可推注玩家        this._tuizhuList = tuizhuList;        this.sendAll(Event.gameBegin, {uids: this.uids}); //发送游戏开始        this.sendAll(Event.canTuizhu, tuizhuList);        // todo: 明牌抢庄才先发2张，大混战直接发牌，九点上装是上局庄家或随机指定，自由抢庄先抢庄        if ([0, 2].indexOf(this.bankerModel) > -1) { // 明牌抢庄/大混战            this.sendHolds2();        }        if (this.bankerModel > 0) {            //隔一秒后，通知前端抢庄            this.setTimeout(() => {                this.changeStatus(Status.WAIT_ROBS_OPEN);                this.sendAll(Event.pleaseRob, {                    max: this._robs //最大倍数                });            }, 1000);        } else {            // todo: 直接发送所有手牌，然后进入搓牌阶段            this.sendHolds1();        }    }    sendHolds2() {        //每人先发2张牌        this.players.forEach(function (el) {            el.sendHolds2();            //发送托管情况            this.sendAll(Event.tuoGuang, [el.uid, el.isTrusteeship]);        }, this);        //通知前端发牌(背牌)        this.sendAll(Event.deal, {num: 2});    }    sendHolds1() {        this.players.forEach(function (el) {            el.sendHolds1();        });        //通知发最后一张牌，进入搓牌状态        this.setTimeout(() => {            this.sendAll(Event.deal, {num: 1});        }, 1000);        /**开始搓牌*/        this.setTimeout(() => {            this.changeStatus(Status.CUOPAI_ONE); //改变状态到搓牌            this.sendAll(Event.startCuoPai);        }, 1500);    }    /**     * 抢庄结束     */    robEnd() {        let arr = [];        //判断是否所有玩家都抢庄        for (let i = 0; i < this.players.length; ++i) {            if (!this.players[i].isRob) {                return;            }        }        //找到抢庄倍数最大的玩家        for (let i = 0; i < this.players.length; ++i) {            let num = this.players[i]._rob;            let has = false;            for (let j = 0; j < this.players.length; ++j) {                if (num < this.players[j]._rob) {                    has = true;                    break;                }            }            if (!has) {                arr.push(this.players[i].uid);                this.maxRob = this.players[i]._rob; //保存最大抢庄倍数            }        }        let delayTime = 500;        //如果都不抢庄随机一个庄家        if (this.maxRob === 0) {            let i = Math.randomRange(0, this.uids.length);            this.zuid = this.players[i].uid;            this.maxRob = 1;            arr = this.uids;            delayTime = 1500;        } else if (arr.length === 1) {            this.zuid = parseInt(arr[0]); //设置为庄家            arr = [this.zuid];        } else {  //多人抢庄，则分数最多的当庄家            let i = Math.randomRange(0, arr.length);            this.zuid = parseInt(arr[i]); //设置为庄家            arr.forEach((uid) => {                let player = this.player(uid);                //没有抢到庄的玩家下注加倍                if (this.anteDouble) {                    if (this.zuid !== uid && player.anteList.length < 3) {                        player.anteList[2] = player.anteList[1] * 2;                    }                }            });            delayTime = 1500;        }        this.sendAll(Event.randomDeclarering, {uids: arr});        this.setTimeout(() => {            this.sendAll(Event.randomDeclarer, {uids: arr, decl: this.zuid});        }, delayTime);        //1秒后通知下注        this.setTimeout(() => {            this.changeStatus(Status.WAIT_BETS);            this.players.forEach(function (el) {                el.sendStartBets();            })        }, delayTime+1000);    }    /**     * 玩家每次下注之后调用     */    betEnd() {        //判断是否所有玩家都下注        for (let i = 0; i < this.players.length; ++i) {            if (this.zuid === this.players[i].uid)                continue;            if (!this.players[i].isBet) {                return;            }        }        // todo: 下注之后如果是明牌抢庄，只发送最后一张牌，然后开始搓牌，        // todo: 如果是其它庄模式，先发两张，再发一张，然后开始搓牌        if (this.bankerModel == 2) {            this.sendHolds1();        } else {            this.sendHolds2();            this.sendHolds1();        }    }    /**     * 亮牌结束     */    async showHoldsEnd() {        //判断是否所有玩家都亮牌了        for (let i = 0; i < this.players.length; ++i) {            if (!this.players[i].isShowHolds) {                return;            }        }        //下一局需要读取的玩家数据,如这把下注，赢的分数，是否推注，等信息        let nextPlayer = {};        let loseSpaceTime = 0;        let winSpaceTime = 0;        //计算结果        if (this.zuid > -1) {            this.countResult();        } else {            this.calculateResult();        }        this.players.forEach(function (el) {            let temp = nextPlayer[el.uid] = {};            if (el.uid !== this.zuid) {                if (el.score >= 0) {                    winSpaceTime = 1500;                } else {                    loseSpaceTime = 1500;                }                //计算推注分数,如果这一把推注了，则下一把不能推注                if (!el.isTuiZhu && el.score > 0) {                    let tz = el.score + el.bet;                    if (tz > this.bets[1]) {                        temp.score = tz > this.maxTuiZhu ? this.maxTuiZhu : tz;                    }                }            }        }.bind(this));        //把推注数据挂到持久层        this.getLasting().players = nextPlayer;        // todo: 九点上庄模式，将拿到最大九点的玩家设置为庄家，放到lasting中，九点上装抢庄倍数为1        //上传分数        let actualScores = await this.pushScore();        delete actualScores[this.zuid];        //玩家总分数        let margin = 0;        if (this.playMode > 0) {            //实际分数还原            let sgscores = this.playerScores.sg;            let jhscores = this.playerScores.jh;            let scale = 1;            for (let uid in sgscores) {                let sgscore = sgscores[uid];                let jhscore = jhscores[uid];                let allscore = sgscore+jhscore;                let actualScore = actualScores[uid];                if (allscore == 0) {                    continue;                }                scale = actualScore/allscore;                break;            }            for (let uid in sgscores) {                sgscores[uid] = Math.floor(sgscores[uid]*scale);                jhscores[uid] = Math.floor(jhscores[uid]*scale);            }            this.sendAll(Event.gameResult, [sgscores, this.zuid, 0]);            this.setTimeout(() => {                this.sendAll(Event.gameResult, [jhscores, this.zuid, 1]);            }, 3000);            margin+=3000;        } else {            //玩家总分数            this.sendAll(Event.gameResult, [actualScores, this.zuid, 0]);        }        //等待前端播放完结果动画，在结束本小局        this.setTimeout(() => {            this.end();        }, winSpaceTime + loseSpaceTime + margin);    }    /**     * 计算结果(带庄模式)     */    countResult() {        // todo: 实现三公的计分方式        this.playerScores = {sg:{}};        if (this.playMode > 0) {            this.playerScores.jh = {};        }        let banker = this.player(this.zuid);        this.players.forEach((player) => {            if (banker.uid !== player.uid) {                //如果庄家大                let sgzscore = 0;                if (banker.checkPattern.value > player.checkPattern.value) {                    let score = banker.checkPattern.multi * player.bet * this.maxRob;                    player.score -= score;                    banker.score += score;                    sgzscore += score;                    this.playerScores.sg[player.uid] = -score;                } else { //闲家赢                    let score = player.checkPattern.multi * player.bet * this.maxRob;                    banker.score -= score;                    player.score += score;                    sgzscore -= score;                    this.playerScores.sg[player.uid] = score;                }                this.playerScores.sgzscore = sgzscore;                if (this.playMode > 0 && !!banker.jinhuaPattern && !!player.jinhuaPattern) {                    let jhzscore = 0;                    if (banker.jinhuaPattern.value > player.jinhuaPattern.value) {                        let score = banker.jinhuaPattern.multi * player.bet * this.maxRob;                        player.score -= score;                        banker.score += score;                        jhzscore += score;                        this.playerScores.jh[player.uid] = -score;                    } else if (banker.jinhuaPattern.value < player.jinhuaPattern.value) { //闲家赢                        let score = player.jinhuaPattern.multi * player.bet * this.maxRob;                        banker.score -= score;                        player.score += score;                        jhzscore -= score;                        this.playerScores.jh[player.uid] = score;                    }                    this.playerScores.jhzscore = jhzscore;                }            }        });    }    /**     * 大混战计分     */    calculateResult() {        let playerList = [];        for (let p of this.players) {            playerList.push({                uid: p.uid,                seatId: p.seatId,                bet: p.bet,                score: p.score,                holdsValue: p.checkPattern.value            });        }        playerList.sort((a, b) => {            return b.holdsValue - a.holdsValue;        });        let loseIndex = playerList.length - 1;        for (let winIndex = 0; winIndex < playerList.length; winIndex++) {            if (winIndex == loseIndex) {                break;            }            let winner = playerList[winIndex];            if (winner.bet == 0) {                continue;            }            for (loseIndex; loseIndex > winIndex; loseIndex--) {                let loser = playerList[loseIndex];                let scoreCanLose = loser.bet + loser.score;                if (scoreCanLose == 0) { // 此输家输的分数已经扣光                    continue;                }                // 赢家还有多少赢分空间                let scoreToWin = winner.bet - winner.score;                if (scoreToWin > scoreCanLose) {                    // 赔不完                    winner.score += scoreCanLose;                    loser.score = -loser.bet;                } else {                    winner.score += scoreToWin;                    loser.score -= scoreToWin;                    // 够赔,走人，下次进来还是从，还有剩余的输家开始赔                    break;                }            }        }        // 把算分结果转移到游戏玩家对象上        for (let ph of playerList) {            let p = this.players[ph.seatId];            // p.balance = ph.balance;            // p.score += p.balance;            p.score = ph.score;        }    }    /**     * 回放战绩     */    getPlayback() {        let data = {};        this.players.forEach(function (el) {            //要保存的历史记录            data[el.uid] = {                holds: el.holds,                value: [el.checkPattern.pattern], //牌型型                score: el.score,                rob: el._rob   //抢庄倍数            };            if (!!el.jinhuaPattern) {                data[el.uid].value.push(el.jinhuaPattern.pattern);            }            if (this.zuid === el.uid) {                data[el.uid].dec = true;            } else {                data[el.uid].bet = el.bet;            }        }.bind(this));        return data;    }    /**     * 找到最大的牌的玩家     */    getMaxHolds() {        let play = this.players[0];        for (let i = 1; i < this.players.length; ++i) {            if (play.checkPattern.value < this.players[i].checkPattern.value) {                play = this.players[i];            }        }        return play;    }    /**     * 下一局的庄家     */    getNextZhuang() {        let play = this.getMaxHolds();        if (play.holdsValue.type >= 10) {            return play.uid;        }        return this.zuid;    }    /**     * 获取分数结果     * @returns {*}     */    getScoreResult() {        let zScore = {win: {}, lose: {}}; //庄家先进钱        let xScore = {win: {}, lose: {}}; //闲家再进钱        let bankerWinScore = 0;        let bankerLoseScore = 0;        this.players.forEach((player) => {            if (parseInt(player.uid) !== this.zuid) {                if (player.score < 0) {                    bankerWinScore += Math.abs(player.score);                    zScore.lose[player.uid] = Math.abs(player.score);                } else {                    bankerLoseScore += Math.abs(player.score);                    xScore.win[player.uid] = Math.abs(player.score);                }            }        });        if (bankerWinScore === 0 && bankerLoseScore === 0) {            xScore.win[this.zuid] = bankerWinScore;            return xScore;        }        //庄家通赔        if (bankerWinScore === 0) {            xScore.lose[this.zuid] = bankerLoseScore;            return xScore;        }        //庄家通吃        if (bankerLoseScore === 0) {            zScore.win[this.zuid] = bankerWinScore;            return zScore;        }        xScore.lose[this.zuid] = bankerLoseScore;        zScore.win[this.zuid] = bankerWinScore;        return [zScore, xScore];    }    /**     * 游戏信息     */    getInfo(uid) {        uid = parseInt(uid);        let msg = {            zuid: this.zuid,            tuizhuList: this._tuizhuList,            status: this.status,            surplusTime: this.getSurplusTime(), //这一状态剩下的时间            uids: this.uids,            multiple: this._robs,            players: {}        };        this.players.forEach(function (el) {            if (uid === el.uid) {                msg.players[el.uid] = el.getInfo();            } else {                msg.players[el.uid] = el.getOtherInfo();            }        }, this);        this.send(uid, Event.gameInfo, msg);    }    /**     * 释放类     */    onDestroy() {        super.onDestroy();    }}module.exports = Main;