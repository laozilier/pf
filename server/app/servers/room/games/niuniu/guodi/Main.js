/** * Created by apple on 2017/11/1. */let BaseMain = require('../../BaseMain');let Player = require('./Player');let alg = require('../../棋牌算法/niuniuAlgorithm');const aliasMethod = require('../../../../../../common/aliasMethod');const nnConst = require('../nnConst');const autoTimes = nnConst.autoTimes;const gameConfig = require('./config');const Event = require('../nnEvent');class Main extends BaseMain {    /**     *     * @param uids  玩家uid列表     * @param rule  游戏规则     * @param room     */    constructor(uids, rule, room) {        super(room);        /**         * @type {[]}         * */        this.players = []; //玩家对象        this.rule = rule; //游戏规则        this.zuid = null; //庄家uid        this.uids = uids; //玩家uid列表        this.maxRob = 0;  //最大抢庄，默认为0        //锅底大小        this.ante = rule.ante;        this.maxBankMul = rule.maxBankMul || 10;        this.minBankMul = rule.minBankMul || 0;        let sd = this.getLasting();        for (let i = 0; i < sd.zcount; i++) {            this.ante = this.ante*2;        }        this.multipleRule = nnConst.getDoublingRule(rule.multipleRule);        this.maxCount = rule.maxCount || 0;        this.shouInning = rule.shouInning || 1;        this.mpHolds = rule.mpHolds || false;        //发牌        let cardsObj = alg.deal(uids.length, {            thsn: rule.isThs,            wxn: rule.isWxn,            zdn: rule.isZdn,            qdn: rule.isQdn,            hln: rule.isHln,            thn: rule.isThn,            whn: rule.isWhn,            sn: rule.isSn,            jpn: rule.isJpn,            wh: rule.wh,            isLaizi: rule.isLaizi        });        this.laizi = cardsObj.laizi;        let holdsList = cardsObj.holds;        //创建玩家        for (let i = 0; i < uids.length; ++i) {            let play = new Player(this, uids[i]);            play.anteList = [this.ante * 0.1, this.ante * 0.2];            play.isTrusteeship = room.player(uids[i]).isTrusteeship; //托管状态            this.players.push(play);  //把玩家保存到这个数组        }        /**根据大小排序*/        holdsList.sort((a, b) => {            return alg.compareHolds(a[1], b[1]) ? 0 : 1;        });        this.deal(holdsList);    }    deal(holdsList) {        let negativeAlias = []; //负幸运的玩家        let alias = [];         //幸运玩家        let robotAlias = [];    //        let normal = [];        //正常玩家        this.players.forEach(player => {            if (player.getRobot()) {                robotAlias.push(player);            } else if (player.getLucky() > 0) {                alias.push(player);            } else if (player.getLucky() < 0) {                negativeAlias.push(player);            } else {                normal.push(player);            }        });        //给负幸运玩家排序        negativeAlias.sort((a, b) => {            return a.getLucky() - b.getLucky();        });        //给正幸运玩家排序        alias.sort((a, b) => {            return b.getLucky() - a.getLucky();        });        //把玩家连接起来,拿牌顺序先负在正在机在普        let tempPlayers = negativeAlias.concat(alias).concat(robotAlias).concat(normal);        let length = tempPlayers.length;        tempPlayers.forEach((player, i) => {            let random = Math.randomRange(0, holdsList.length);            if (length - i > 1) { //玩家数大于1才能使用概率                if (player.getRobot()) { //机器人概率                    alias = gameConfig.robotAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if (player.getLucky() > 0) { //幸运概率                    alias = gameConfig.alias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if (player.getLucky() < 0) { //负幸运概率                    alias = gameConfig.negativeAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                }            }            let holds = holdsList.splice(random, 1)[0];            player.holds = holds[0];      //设置牌            player.holdsValue = holds[1]; //设置值            if (player.getRobot()) {                player.fourCardsValue = player.holdsValue.type;            }        });    }    /**     * 判断当前状态     * @param s     * @return {boolean}     */    isStatus(s) {        return (parseInt(s) === this.status);    }    /**     * 计时器     * @param cb     */    schedule(cb) {        this.clearTimeout(this.timeoutId);        this.optEndTime = Date.now() + (autoTimes[this.status] * 1000);        let times = (autoTimes[this.status] * 1000);        this.timeoutId = this.setTimeout(cb, times);    }    /**     * 获取这一状态还剩多少时间     */    getSurplusTime() {        let t = this.optEndTime - Date.now();        return t > 0 ? t : 0;    }    /**     * 改变状态     * @param code 状态码     */    changeStatus(code) {        //设置状态        this.status = code;        this.sendAll(Event.gameStatus, {status: code});        switch (code) {            case nnConst.等待上庄:                /** 一定时间后玩家自动放弃 **/                this.schedule(function () {                    let p = this.player(this.nextzuid);                    if (!!p) {                        this.res_zhuang_next(this.nextzuid, false);                    }                });                /** 自动操作托管玩家 **/                this.setTimeout(() => {                    let p = this.player(this.nextzuid);                    if (!!p && p.isTrusteeship) {                        this.res_zhuang_next(this.nextzuid, false);                    }                }, 1000);                break;            case nnConst.WAIT_ROBS_OPEN:                /** 一定时间后所有玩家自动抢庄 **/                this.schedule(function () {                    this.players.forEach(function (el) {                        el.setMultiple(0);                    });                });                /** 自动操作托管玩家 **/                this.setTimeout(() => {                    this.players.forEach((el) => {                        if (el.isTrusteeship) {                            el.setMultiple(0);                        }                    });                }, 1000);                break;            case nnConst.WAIT_BETS:                //一定时间后所有玩家自动下注                this.schedule(function () {                    this.players.forEach(function (el) {                        el.setBet(0);                    })                });                //自动操作托管玩家                this.setTimeout(() => {                    this.players.forEach((el) => {                        if (el.isTrusteeship) {                            el.setBet(0);                        }                    }, this);                }, 1000);                break;            case nnConst.CUOPAI_ONE:                this.schedule(function () {                    this.players.forEach(function (el) {                        el.showHolds();                    })                });                //托管玩家直接亮牌                this.setTimeout(() => {                    this.players.forEach(function (el) {                        if (el.isTrusteeship) {                            el.showHolds();                        }                    });                }, 1000);                break;        }    }    /**     * 游戏开始的接口     */    begin() {        /** 游戏开始 **/        this.sendAll(Event.gameBegin, {uids: this.uids});        /** 赖子 **/        if (this.laizi > -1) {            this.sendAll("laiziPoker", {laizi: this.laizi});            // this.setTimeout(() => {            //     this.nextBegin();            // }, 500);        } else {            // this.nextBegin();        }        this.nextBegin();    }    nextBegin() {        /**         * this.getLasting().zuid       当前庄家uid         * this.getLasting().lastzuid   上一把的庄家uid         * this.getLasting().lastuids   上一把的玩家         * this.getLasting().zhuangInning  当前庄家的局数         * this.getLasting().zcount     连庄次数         * this.getLasting().guodi      锅底         * **/        let sd = this.getLasting();        if (!!sd.zuid && this.uids.indexOf(sd.zuid) > -1) {            this.zuid = sd.zuid;            this.sendAll(Event.randomDeclarer, {decl: this.zuid, guodi: sd.guodi});        }        this.players.forEach(function (el) {            /** 发送托管情况 **/            this.sendAll(Event.tuoGuang, [el.uid, el.isTrusteeship]);        }, this);        /** 如果有庄家 则直接通知其他玩家下注 **/        if (!!this.zuid) {            if (this.mpHolds) {                /** 每人先发四张牌 */                this.players.forEach(function (el) {                    el.sendHolds4();                }, this);                /** 通知前端发牌 */                this.sendAll(Event.deal, {num: 4});                /** 通知其他玩家下注 **/                this.setTimeout(() => {                    this.changeStatus(nnConst.WAIT_BETS);                    this.players.forEach(function (el) {                        el.sendStartBets(sd.guodi);                    });                }, 1000);            } else {                /** 通知其他玩家下注 **/                this.changeStatus(nnConst.WAIT_BETS);                this.players.forEach(function (el) {                    el.sendStartBets(sd.guodi);                });            }        } else {            /** 询问是否连庄 如果上一局的庄家走了 则询问下一个玩家当庄 **/            let lastzuid = sd.lastzuid;            if (this.uids.indexOf(lastzuid) < 0) {                this.nextZhunag();            } else {                /** 如果能连庄 且还有连庄次数 且分数足够 则询问连庄 **/                let canlianzhuang = sd.canlianzhuang;                let zcount = sd.zcount;                let lastplayer = this.room.player(lastzuid);                if (canlianzhuang && zcount <= this.maxCount && lastplayer && lastplayer.getActualScore() >= this.ante) {                    this.changeStatus(nnConst.等待上庄);                    this.send_ask_lianzhuang(lastzuid, zcount);                    this.nextzuid = lastzuid;                } else {                    this.nextZhunag();                }            }        }    }    /**     * 询问玩家连庄     * @param uid     * @param zcount     */    send_ask_lianzhuang(uid, zcount) {        this.sendAll(Event.ask_lianzhuang, {uid: uid, zcount: zcount});    }    /**     * 玩家回复连庄     * @param uid     * @param isRob     */    res_lianzhuang(uid, isRob) {        if (!!this.zuid) {            return;        }        /** 只有被询问的人才可以选择连庄 **/        if (uid != this.nextzuid) {            return;        }        this.res_zhuang_next(uid, isRob);    }    /**     * 玩家回复当庄     * @param uid     * @param isRob     */    res_dangzhuang(uid, isRob) {        if (!!this.zuid) {            return;        }        /** 只有被询问的人才可以选择当庄 **/        if (uid != this.nextzuid) {            return;        }        this.res_zhuang_next(uid, isRob);    }    /**     * 玩家回复当庄下一步     * @param uid     * @param isRob     * @param arr     */    res_zhuang_next(uid, isRob, arr) {        let sd = this.getLasting();        if (isRob) {            this.zuid = uid;            sd.zuid = uid;            sd.lastzuid = uid;            sd.zhuangInning = 0;            this.sendAll(Event.randomDeclarer, {decl: this.zuid, uids: arr});            /** 等待0.5秒 通知庄家下锅底 **/            this.sendStartGuodi(500);        } else {            sd.lastzuid = uid;            this.nextZhunag();        }    }    /** 获取应该谁当庄 **/    nextZhunag() {        if (!!this.zuid) {            return;        }        let sd = this.getLasting();        sd.zcount = 0;        this.ante = this.rule.ante;        this.players.forEach((el) => {            el.anteList = [this.ante * 0.1, this.ante * 0.2];        });        let lastzuid = sd.lastzuid;        let lastuids = sd.lastuids;        if (!!lastzuid && !!lastuids) {            /** 上一把庄家的数组位置 **/            let lastidx = lastuids.indexOf(lastzuid);            let count = 1;            let idx = lastidx+1;            idx = idx < lastuids.length ? idx : 0;            /** 获取这一把应该当庄的uid **/            let nextzuid = lastuids[idx];            /** 获取这个uid在当前当前这一局中的数组位置 **/            let curidx = this.uids.indexOf(nextzuid);            /** 如果未获取到 也就是玩家走了 则继续找下一个 直到找到或者遍历完为止 **/            while (curidx < 0) {                count+=1;                idx+=1;                idx = idx < lastuids.length ? idx : 0;                nextzuid = lastuids[idx];                curidx = this.uids.indexOf(nextzuid);                if (count >= lastuids.length) {                    break;                }            }            if (curidx < 0) {                /** 没有符合条件的 则随机抢庄 **/                this.sendPleaseRob();            } else {                /** 有符合条件的 则询问是否当庄 **/                this.changeStatus(nnConst.等待上庄);                this.sendAll(Event.ask_dangzhuang, [nextzuid, this.nextzuid]);                this.nextzuid = nextzuid;            }        } else {            this.sendPleaseRob();        }    }    sendPleaseRob() {        this.changeStatus(nnConst.WAIT_ROBS_OPEN);        this.sendAll(Event.pleaseRob, {            max: 1        });    }    /** 通知庄下注锅底 **/    sendStartGuodi(delayTime) {        delayTime += 1000;        /** 1秒后通知下注锅底 **/        this.setTimeout(() => {            let guodi = this.ante;            this.getLasting().guodi = guodi;            this.sendAll(Event.start_guodi, {uid: this.zuid, score: this.ante});        }, delayTime);        if (this.mpHolds) {            delayTime += 1000;            this.setTimeout(() => {                /** 每人先发四张牌 */                this.players.forEach(function (el) {                    el.sendHolds4();                }, this);                /** 通知前端发牌 */                this.sendAll(Event.deal, {num: 4});            }, delayTime);        }        delayTime += 500;        /** 过0.5秒后通知其他玩家下注 **/        this.setTimeout(() => {            this.changeStatus(nnConst.WAIT_BETS);            this.players.forEach((el) => {                el.sendStartBets(this.getLasting().guodi);            })        }, delayTime);    }    /**     * 抢庄结束     */    robEnd() {        let arr = [];        //判断是否所有玩家都抢庄        for (let i = 0; i < this.players.length; ++i) {            if (!this.players[i].isRob) {                return;            }        }        //找到抢庄倍数最大的玩家        for (let i = 0; i < this.players.length; ++i) {            let num = this.players[i]._rob;            let has = false;            for (let j = 0; j < this.players.length; ++j) {                if (num < this.players[j]._rob) {                    has = true;                    break;                }            }            if (!has) {                arr.push(this.players[i].uid);                this.maxRob = this.players[i]._rob; //保存最大抢庄倍数            }        }        let delayTime = 500;        //如果都不抢庄随机一个庄家        if (this.maxRob === 0) {            let i = Math.randomRange(0, this.uids.length);            this.zuid = this.players[i].uid;            this.maxRob = 1;            arr = this.uids;            delayTime = 1500;        } else if (arr.length === 1) {            this.zuid = parseInt(arr[0]); //设置为庄家            arr = [this.zuid];        } else {  //多人抢庄，则分数最多的当庄家            let i = Math.randomRange(0, arr.length);            this.zuid = parseInt(arr[i]); //设置为庄家            delayTime = 1500;        }        this.sendAll(Event.randomDeclarering, {uids: arr});        this.setTimeout(() => {            this.res_zhuang_next(this.zuid, true, arr);        }, delayTime);    }    /**     * 玩家每次下注之后调用     */    betEnd() {        //判断是否所有玩家都下注        for (let i = 0; i < this.players.length; ++i) {            if (this.zuid === this.players[i].uid)                continue;            if (!this.players[i].isBet) {                return;            }        }        /** 通知发牌，进入搓牌状态 **/        if (this.mpHolds) {            this.setTimeout(() => {                this.players.forEach(function (el) {                    el.sendHolds1();                });                this.sendAll(Event.deal, {num: 1});            }, 1000);        } else {            this.setTimeout(() => {                this.players.forEach(function (el) {                    el.sendHolds5();                });                this.sendAll(Event.deal, {num: 5});            }, 1000);        }        /**开始搓牌*/        this.setTimeout(() => {            this.changeStatus(nnConst.CUOPAI_ONE); //改变状态到搓牌        }, 1500);    }    /**     * 亮牌结束     */    async showHoldsEnd() {        //判断是否所有玩家都亮牌了        for (let i = 0; i < this.players.length; ++i) {            if (!this.players[i].isShowHolds) {                return;            }        }        let loseSpaceTime = 500;        let winSpaceTime = 500;        //计算牌局分数        this.calculateScorer();        //上传分数        let actualScores = await this.pushScore();        delete actualScores[this.zuid];        APP_LOG.log(actualScores);        let sd = this.getLasting();        sd.lastuids = this.uids;        //玩家总分数        this.sendAll(Event.gameResult, [actualScores, this.zuid, sd.guodi]);        sd.zhuangInning += 1;        if (sd.guodi > 0) {            if (sd.guodi >= this.ante*this.maxBankMul) {                this.sendAll('toast', `锅底已经超过底注${this.maxBankMul}倍，庄家收庄`);                sd.canShouZhuang = true;                this.room.res_shouzhuang(this.zuid, true, true);            } else if (sd.guodi < this.room.tax) {                this.sendAll('toast', '锅底已经小于税钱，庄家下庄');                this.xia_zhuang();            } else if (sd.guodi < this.ante*this.minBankMul) {                this.sendAll('toast', `锅底已经小于底注${Math.floor(this.minBankMul*100)}%，庄家下庄`);                this.xia_zhuang();            } else {                if (sd.zhuangInning >= this.shouInning) {                    sd.canShouZhuang = true;                    this.sendAll(Event.ask_shouzhuang, [this.zuid, sd.guodi]);                }            }        } else {            this.sendAll('toast', '锅底已输光，庄家下庄');            this.xia_zhuang();        }        /** 等待前端播放完结果动画，在结束本小局 */        this.setTimeout(() => {            this.end();        }, winSpaceTime + loseSpaceTime);    }    /**     * 下庄     */    xia_zhuang() {        let sd = this.getLasting();        sd.zuid = undefined;        sd.zhuangInning = 0;    /** 庄打的局数重置为0 **/        sd.canlianzhuang = true;/** 可以连庄 **/        sd.zcount += 1;         /** 连庄次数+1 **/        sd.canShouZhuang = false;        this.sendAll(Event.xiazhuang, [this.zuid, sd.guodi]);    }    /**     * 计算结果     */    calculateScorer() {        let banker = this.player(this.zuid);        this.players.forEach((player) => {            if (banker.uid !== player.uid) {                //如果庄家大                if (alg.compareHolds(banker.holdsValue, player.holdsValue)) {                    let score = this.typeScore(banker.holdsValue.type, player.bet);                    player.score -= score;                    banker.score += score;                } else { //闲家赢                    let score = this.typeScore(player.holdsValue.type, player.bet);                    banker.score -= score;                    player.score += score;                }            }        });    }    /**     * 回放战绩     */    getPlayback() {        let data = {multipleRule: this.rule.multipleRule, laizi: this.laizi};        this.players.forEach(function (el) {            //要保存的历史记录            data[el.uid] = {                holds: el.holds,                value: el.holdsValue.type, //牛类型                jinpai: el.holdsValue.jinpai, //是否金牌牛                score: el.score,                rob: el._rob   //抢庄倍数            };            if (this.zuid === el.uid) {                data[el.uid].dec = true;            } else {                data[el.uid].bet = el.bet;            }        }.bind(this));        return data;    }    /**     * 根据牛的类型计算分数     * @param {Object} type   牛几     * @param ante    底注     * @returns {number} 计算完的分数     */    typeScore(type, ante) {        let mul = this.multipleRule[type]; //翻倍数        return mul * ante;    }    /**     * 获取分数结果     * @returns {*}     */    getScoreResult() {        let res = {win: [], lose: [], zuid: this.zuid};        this.players.forEach((player) => {            if (parseInt(player.uid) !== this.zuid) {                if (player.score < 0) {                    res.lose.push({uid: player.uid, score: Math.abs(player.score)})                } else {                    res.win.push({uid: player.uid, score: Math.abs(player.score)});                }            }            /** 给赢的闲家排序 因为要按大小进钱 */            res.win.sort((a, b) => {                let item_a = this.player(a.uid);                let item_b = this.player(b.uid);                if(alg.compareHolds(item_a.holdsValue, item_b.holdsValue)) {                    return -1;                } else {                    return 1;                }            });        });        return res;    }    /**     * 游戏信息     */    getInfo(uid) {        uid = parseInt(uid);        let msg = {            zuid: this.zuid,            nextzuid: this.nextzuid,            zcount: this.getLasting().zcount,            status: this.status,            surplusTime: this.getSurplusTime(), //这一状态剩下的时间            uids: this.uids,            multiple: 1,            laizi: this.laizi,            guodi: this.getLasting().guodi,            players: {}        };        this.players.forEach(function (el) {            if (uid === el.uid) {                msg.players[el.uid] = el.getInfo();            } else {                msg.players[el.uid] = el.getOtherInfo();            }        }, this);        this.send(uid, Event.gameInfo, msg);    }    /**     * 释放类     */    onDestroy() {        super.onDestroy();    }}module.exports = Main;