/** * Created by apple on 2017/11/1. */let BaseMain = require('../../BaseMain');let Player = require('./Player');let alg = require('../../棋牌算法/niuniuAlgorithm');const aliasMethod = require('../../../../../../common/aliasMethod');const nnConst = require('../nnConst');const autoTimes = nnConst.autoTimes;const gameConfig = require('./config');const Event = require('../nnEvent');/** *  规则信息 account:cc.user.account, //账号 sign:cc.user.sign,       //sign证验码 uid:cc.user.uid, game_type:0, max:0,        //最大局数 halfway:true, //是否中途加入 game_rule:{                difen:0,        底分 id                tuizhu:0,       推注 id                multiple:0,     倍数 id  抢庄倍数                multipleRule:0, 翻倍规则                dScore:0,       庄家                isCp:false,     是否搓 牌                isWhn:false,    是否五小牛                isZdn:false,    是否炸弹牛                isWxn:false,    五花牛                isHln:false,    葫芦牛                isThn:false,    同花牛                isSn:false      顺子牛            } */class Main extends BaseMain {    /**     *     * @param uids  玩家uid列表     * @param rule  游戏规则     */    constructor(uids, rule, room) {        super(room);        /**         * @type {[]}         * */        this.players = []; //玩家对象        this.rule = rule; //游戏规则        this.zuid = null; //庄家uid        this.uids = uids; //玩家uid列表        //下注底分        let rulebets = isNaN(rule.bets) ? 0 : rule.bets;        rulebets+=2;        rulebets = Math.min(rulebets, 5);        this.bets = [];        for (let i = 0; i < rulebets; i++) {            if (isNaN(rule.ante)) {                this.bets.push((i+1));            } else {                this.bets.push((i+1)*parseInt(rule.ante));            }        }        /*        this.bets = rulebets > 0 ? [1, 2, 3, 4, 5] : [1, 2];        if (!isNaN(rule.ante)) {            this.bets = rulebets > 0 ? [                parseInt(rule.ante),                parseInt(rule.ante) * 2,                parseInt(rule.ante) * 3,                parseInt(rule.ante) * 4,                parseInt(rule.ante) * 5            ] : [                parseInt(rule.ante),                parseInt(rule.ante) * 2            ];        }        */        //推注        this.tuizhu = gameConfig.tuizhus[rule.tuizhu]; //推注倍数        this.tuizhu || (this.tuizhu = gameConfig.tuizhus[0]);        //最大推注分数        this.maxTuiZhu = this.tuizhu === 1 ? 0 : this.tuizhu * this.bets[0]; //最大推注分数        //翻倍规则        let multipleRules = [            [1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10],            [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 16],        ];        this.multipleRule = multipleRules[rule.multipleRule];        this.multipleRule = this.multipleRule || multipleRules[0];        //抢庄倍数        this._robs = gameConfig.multiple[rule.multiple] || 1;        this.maxRob = 0; //最大抢庄倍数        //下注加倍        this.anteDouble = !!this.rule.anteDouble;        this.status = nnConst.BEGIN;// 1.等待下注状态; 2.等待搓牌状态; 3等待抢庄状态        //发牌        let cardsObj = alg.deal(uids.length, {            thsn: rule.isThs,            wxn: rule.isWxn,            zdn: rule.isZdn,            qdn: rule.isQdn,            hln: rule.isHln,            thn: rule.isThn,            whn: rule.isWhn,            sn: rule.isSn,            jpn: rule.isJpn,            wh: rule.wh,            isLaizi: rule.isLaizi        });        this.laizi = cardsObj.laizi;        let holdsList = cardsObj.holds;        //创建玩家        for (let i = 0; i < uids.length; ++i) {            let play = new Player(this, uids[i]);            play.anteList = this.bets.slice(0, this.bets.length); //保存下注列表            play.isTrusteeship = room.player(uids[i]).isTrusteeship; //托管状态            this.players.push(play);  //把玩家保存到这个数组        }        /**根据大小排序*/        holdsList.sort((a, b) => {            return alg.compareHolds(a[1], b[1]) ? 0 : 1;        });        this.deal(holdsList);    }    deal(holdsList){        let negativeAlias = []; //负幸运的玩家        let alias = [];         //幸运玩家        let robotAlias = [];    //        let normal = [];        //正常玩家        this.players.forEach(player => {            if(player.getRobot()){                robotAlias.push(player);            } else if(player.getLucky() > 0){                alias.push(player);            } else if(player.getLucky() < 0){                negativeAlias.push(player);            } else {                normal.push(player);            }        });        //给负幸运玩家排序        negativeAlias.sort((a, b) => {            return a.getLucky() - b.getLucky();        });        //给正幸运玩家排序        alias.sort((a, b) => {            return b.getLucky() - a.getLucky();        });        //把玩家连接起来,拿牌顺序先负在正在机在普        let tempPlayers = negativeAlias.concat(alias).concat(robotAlias).concat(normal);        let length = tempPlayers.length;        tempPlayers.forEach((player, i) => {            let random = Math.randomRange(0, holdsList.length);            if (length - i > 1) { //玩家数大于1才能使用概率                if (player.getRobot()) { //机器人概率                    alias = gameConfig.robotAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if(player.getLucky() > 0){ //幸运概率                    alias = gameConfig.alias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                } else if(player.getLucky() < 0){ //负幸运概率                    alias = gameConfig.negativeAlias[length - i];                    random = aliasMethod.generation(alias.prob, alias.alias);                }            }            let holds = holdsList.splice(random, 1)[0];            player.holds = holds[0];      //设置牌            player.holdsValue = holds[1]; //设置值            if (player.getRobot()) {                player.fourCardsValue = player.holdsValue.type;            }        });    }    /**     * 判断当前状态     * @param s     * @return {boolean}     */    isStatus(s) {        return (parseInt(s) === this.status);    }    /**     * 计时器     * @param cb     */    schedule(cb) {        this.clearTimeout(this.timeoutId);        this.optEndTime = Date.now() + (autoTimes[this.status] * 1000);        let times = (autoTimes[this.status] * 1000);        this.timeoutId = this.setTimeout(cb, times);    }    player(uid) {        for (let i = 0; i < this.players.length; ++i) {            if (this.players[i].uid === parseInt(uid)) {                return this.players[i];            }        }        return null;    }    /**     * 获取这一状态还剩多少时间     */    getSurplusTime() {        let t = this.optEndTime - Date.now();        return t > 0 ? t : 0;    }    /**     * 改变状态     * @param code 状态码     */    changeStatus(code) {        //设置状态        this.status = code;        this.sendAll(Event.gameStatus, {status: code});        switch (code) {            case nnConst.WAIT_ROBS_OPEN:                this.schedule(function () {                    this.players.forEach(function (el) {                        el.setMultiple(0);                    });                });                //自动操作托管玩家                this.setTimeout(() => {                    this.players.forEach((el) => {                        if (el.isTrusteeship) {                            el.setMultiple(0);                        }                    });                }, 1000);                break;            case nnConst.WAIT_BETS:                //一定时间后所有玩家自动下注                this.schedule(function () {                    this.players.forEach(function (el) {                        el.setBet(0);                    })                });                //自动操作托管玩家                this.setTimeout(() => {                    this.players.forEach((el) => {                        if (el.isTrusteeship) {                            el.setBet(0);                        }                    }, this);                }, 1000);                break;            case nnConst.CUOPAI_ONE:                this.schedule(function () {                    this.players.forEach(function (el) {                        el.showHolds();                    })                });                //托管玩家直接亮牌                this.setTimeout(() => {                    this.players.forEach(function (el) {                        if (el.isTrusteeship) {                            el.showHolds();                        }                    });                }, 1000);                break;        }    }    /**     * 游戏开始的接口     */    begin() {        //赖子        this.sendAll(Event.gameBegin, {uids: this.uids}); //发送游戏开始        if (this.laizi > -1) {            this.sendAll("laiziPoker", {laizi: this.laizi});        //     //隔一秒后，通知前端抢庄        //     this.setTimeout(() => {        //         this.nextBegin();        //     }, 500);        } else {        //     this.nextBegin();        }        this.nextBegin();    }    nextBegin() {        //可推注玩家列表        this.tuizhuList = [];        //计算推注分数        if (Object.keys(this.room.sd).length > 0) {            //推注分数            if (this.tuizhu > 1) {                for (let uid in this.room.sd.players) {                    //上一把赢的分数                    let s = this.room.sd.players[uid].score || 0;                    if (parseInt(s) > 0) {                        let player = this.player(uid);                        if (player) {                            player.anteList.push(parseInt(s));                            player.canTuizhu = true;                            this.tuizhuList.push(parseInt(uid));                        }                    }                }            }        }        //可推注玩家        this.sendAll(Event.canTuizhu, this.tuizhuList);        if (this.laizi > -1) {            this.sendAll("laiziPoker", {laizi: this.laizi});        }        //每人先发四张牌        this.players.forEach(function (el) {            el.sendHolds4();            //发送托管情况            this.sendAll(Event.tuoGuang, [el.uid, el.isTrusteeship]);        }, this);        //通知前端发牌        this.sendAll(Event.deal, {num: 4});        //隔一秒后，通知前端抢庄        this.setTimeout(() => {            this.changeStatus(nnConst.WAIT_ROBS_OPEN);            this.sendAll(Event.pleaseRob, {                max: this._robs //最大倍数            });        }, 1000);    }    /**     * 抢庄结束     */    robEnd() {        let arr = [];        //判断是否所有玩家都抢庄        for (let i = 0; i < this.players.length; ++i) {            if (!this.players[i].isRob) {                return;            }        }        //找到抢庄倍数最大的玩家        for (let i = 0; i < this.players.length; ++i) {            let num = this.players[i]._rob;            let has = false;            for (let j = 0; j < this.players.length; ++j) {                if (num < this.players[j]._rob) {                    has = true;                    break;                }            }            if (!has) {                arr.push(this.players[i].uid);                this.maxRob = this.players[i]._rob; //保存最大抢庄倍数            }        }        let delayTime = 500;        //如果都不抢庄随机一个庄家        if (this.maxRob === 0) {            let i = Math.randomRange(0, this.uids.length);            this.zuid = this.players[i].uid;            this.maxRob = 1;            arr = this.uids;            delayTime = 1500;        } else if (arr.length === 1) {            this.zuid = parseInt(arr[0]); //设置为庄家            arr = [this.zuid];        } else {  //多人抢庄，则分数最多的当庄家            let i = Math.randomRange(0, arr.length);            this.zuid = parseInt(arr[i]); //设置为庄家            arr.forEach((uid) => {                let player = this.player(uid);                //没有抢到庄的玩家下注加倍                if (this.anteDouble) {                    if (this.zuid !== uid && player.anteList.length < 3) {                        player.anteList[2] = player.anteList[1] * 2;                    }                }            });            delayTime = 1500;        }        this.sendAll(Event.randomDeclarering, {uids: arr});        this.setTimeout(() => {            this.sendAll(Event.randomDeclarer, {uids: arr, decl: this.zuid});        }, delayTime);        //1秒后通知下注        this.setTimeout(() => {            this.changeStatus(nnConst.WAIT_BETS);            this.players.forEach(function (el) {                el.sendStartBets();            })        }, delayTime+500);    }    /**     * 玩家每次下注之后调用     */    betEnd() {        //判断是否所有玩家都下注        for (let i = 0; i < this.players.length; ++i) {            if (this.zuid === this.players[i].uid)                continue;            if (!this.players[i].isBet) {                return;            }        }        //通知发最后一张牌，进入搓牌状态        this.setTimeout(() => {            this.players.forEach(function (el) {                el.sendHolds1();            });            this.sendAll(Event.deal, {num: 1});        }, 1000);        /**开始搓牌*/        this.setTimeout(() => {            this.changeStatus(nnConst.CUOPAI_ONE); //改变状态到搓牌            this.sendAll(Event.startCuoPai);        }, 1500);    }    /**     * 亮牌结束     */    async showHoldsEnd() {        //判断是否所有玩家都亮牌了        for (let i = 0; i < this.players.length; ++i) {            if (!this.players[i].isShowHolds) {                return;            }        }        //下一局需要读取的玩家数据,如这把下注，赢的分数，是否推注，等信息        let nextPlayer = {};        let loseSpaceTime = 0;        let winSpaceTime = 0;        //计算结果        this.countResult();        this.players.forEach(function (el) {            let temp = nextPlayer[el.uid] = {};            if (el.uid !== this.zuid) {                if (el.score >= 0) {                    winSpaceTime = 1500;                } else {                    loseSpaceTime = 1500;                }                //计算推注分数,如果这一把推注了，则下一把不能推注                if (!el.isTuiZhu && el.score > 0) {                    let tz = el.score + el.bet;                    if (tz > this.bets[1]) {                        temp.score = tz > this.maxTuiZhu ? this.maxTuiZhu : tz;                    }                }            }        }.bind(this));        //把推注数据挂到持久层        this.getLasting().players = nextPlayer;        //上传分数        let actualScores = await this.pushScore();        delete actualScores[this.zuid];        //玩家总分数        this.sendAll(Event.gameResult, [actualScores, this.zuid]);        //等待前端播放完结果动画，在结束本小局        this.setTimeout(() => {            this.end();        }, winSpaceTime + loseSpaceTime);    }    /**     * 计算结果     */    countResult() {        let banker = this.player(this.zuid);        this.players.forEach((player) => {            if (banker.uid !== player.uid) {                //如果庄家大                if (alg.compareHolds(banker.holdsValue, player.holdsValue)) {                    let score = this.getScore(banker.holdsValue.type, player.bet);                    player.score -= score;                    banker.score += score;                } else { //闲家赢                    let score = this.getScore(player.holdsValue.type, player.bet);                    banker.score -= score;                    player.score += score;                }            }        });    }    /**     * 回放战绩     */    getPlayback() {        let data = {multipleRule: this.rule.multipleRule, laizi: this.laizi};        this.players.forEach(function (el) {            //要保存的历史记录            data[el.uid] = {                holds: el.holds,                value: el.holdsValue.type, //牛类型                jinpai: el.holdsValue.jinpai, //是否金牌牛                score: el.score,                rob: el._rob   //抢庄倍数            };            if (this.zuid === el.uid) {                data[el.uid].dec = true;            } else {                data[el.uid].bet = el.bet;            }        }.bind(this));        return data;    }    /**     * 根据牛的类型计算分数     * @param {Object} type   牛类型     * @param ante    底注     * @returns {number} 计算完的分数     */    getScore(type, ante) {        let mul = this.multipleRule[type]; //翻倍数        return mul * ante * this.maxRob;    }    /**     * 找到最大的牌的玩家     */    getMaxHolds() {        let play = this.players[0];        for (let i = 1; i < this.players.length; ++i) {            if (!alg.compareHolds(play.holdsValue, this.players[i].holdsValue)) {                play = this.players[i];            }        }        return play;    }    /**     * 下一局的庄家     */    getNextZhuang() {        let play = this.getMaxHolds();        if (play.holdsValue.type >= 10) {            return play.uid;        }        return this.zuid;    }    /**     * 获取分数结果     * @returns {*}     */    getScoreResult() {        let zScore = {win: {}, lose: {}}; //庄家先进钱        let xScore = {win: {}, lose: {}}; //闲家再进钱        let bankerWinScore = 0;        let bankerLoseScore = 0;        this.players.forEach((player) => {            if (parseInt(player.uid) !== this.zuid) {                if (player.score < 0) {                    bankerWinScore += Math.abs(player.score);                    zScore.lose[player.uid] = Math.abs(player.score);                } else {                    bankerLoseScore += Math.abs(player.score);                    xScore.win[player.uid] = Math.abs(player.score);                }            }        });        //庄家通赔        if (bankerWinScore === 0) {            xScore.lose[this.zuid] = bankerLoseScore;            return xScore;        }        //庄家通吃        if (bankerLoseScore === 0) {            zScore.win[this.zuid] = bankerWinScore;            return zScore;        }        xScore.lose[this.zuid] = bankerLoseScore;        zScore.win[this.zuid] = bankerWinScore;        return [zScore, xScore];    }    /**     * 游戏信息     */    getInfo(uid) {        uid = parseInt(uid);        let msg = {            zuid: this.zuid,            status: this.status,            surplusTime: this.getSurplusTime(), //这一状态剩下的时间            uids: this.uids,            multiple: this._robs,            laizi: this.laizi,            tuizhuList: this.tuizhuList,            players: {}        };        this.players.forEach(function (el) {            if (uid === el.uid) {                msg.players[el.uid] = el.getInfo();            } else {                msg.players[el.uid] = el.getOtherInfo();            }        }, this);        this.send(uid, Event.gameInfo, msg);    }    /**     * 释放类     */    onDestroy() {        super.onDestroy();    }}module.exports = Main;