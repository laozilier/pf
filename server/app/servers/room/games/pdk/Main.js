/** * * 跑得快游戏 * Created by apple on 2018/1/16. */const Player = require('./Player');const algorithm = require('../棋牌算法/pdkAlgorithm');const Event = require('./Event');class Main extends require('../BaseMain') {    constructor(uids, rule, room) {        super(room);        this.rule = rule;        /**         * 可拆炸弹         * @type {boolean} true 可拆 反之不可拆         */        this.dismantleBomb = (rule.gameRules.indexOf(1) === -1);        /**         * 允许四带二         * @type {boolean} true 允许 反之不允许         */        this.fourBandTwo = (rule.gameRules.indexOf(2) !== -1);        /**         * 允许四带三         * @type {boolean} true 允许 反之不允许         */        this.fourBandThree = (rule.gameRules.indexOf(3) !== -1);        /**         * 红桃10托鸟         * @type {boolean} true 扎鸟 反之不扎鸟         */        this.zaniao = (rule.gameRules.indexOf(4) !== -1);        /**         * 三张少带出完         * @type {boolean} true 可以  反之不可以         */        this.sanzhangchuwan = (rule.playTypes.indexOf(1) !== -1);        /**         * 三张少带接完         * @type {boolean} true 可以         */        this.sanzhangjiewan = (rule.playTypes.indexOf(2) !== -1);        /**         * 飞机少带出完         * @type {boolean} true 可以  反之不可以         */        this.feijichuwan = (rule.playTypes.indexOf(3) !== -1);        /**         * 飞机少带接完         * @type {boolean} true 可以         */        this.feijijiewan = (rule.playTypes.indexOf(4) !== -1);        /**         * 防作弊         * @type {boolean} true 开启         */        this.antiCheating = rule.stopCheatings;        /**         * 牌数量是否可见         * @type {boolean} true 可见         */        this.numVisibles = rule.isVisibles;        /**         * 默认随机庄家先出         * @type {boolean} true 随机庄家先出         */        this.firstBank = rule.throwCards;        /**         * 默认16张         * @type {boolean} true 16张 反之 15张         */        this.model = rule.model;        /**         * 默认2人         * @type {number} true 2人 反之 3人         */        this.renshu = rule.renshu ? 2 : 3;        /***         *  小通机制   默认不开         * @type {boolean} true 开启         */        this.smallTong = (rule.playTypes.indexOf(5) !== -1);        /***         *  双报    默认不开         * @type {boolean} true 开启         */        this.doubleQuote = (rule.playTypes.indexOf(6) !== -1);        /**保存玩家出的牌,经过转换的*/        this.foldsList = [];        /**保存玩家的牌，用来实现战绩回放*/        this.holdsList = {};        /**底分*/        this.ante = rule.ante ? rule.ante : 100;        /**         * 玩家uid列表         * @type {Array}         */        this.uids = uids;        /**         * 庄家uid         * @type {Number}         */        this.zuid = undefined;        /**         *  切牌者uid         * @type {Number}         */        this.quid = undefined;        /**         * 是否切牌         */        this.isQie = false;        /**         * 玩家对象         * @type {Array}         */        this.players = [];        /**         * 当前出牌的玩家uid         * @type {*}         */        this.turn = -1;        /**         * 玩家当前打出的牌         * @type {{}}         */        this.currentPoker = undefined;        /**炸弹统计*/        this.bombCount = 0;        /**  整局的牌 **/        this.allCard = undefined;        //创建玩家        this.uids.forEach((uid, i) => {            if (i < this.renshu) {                let player = new Player(this);                player.uid = uid;                player.seatId = i;                player.isTrusteeship = room.player(uids[i]).isTrusteeship; //托管状态                this.players.push(player);            }        }, this);        //切牌人        if (this.uids.includes(this.getLasting().winnerUid)) {  //有赢家            this.zuid = this.getLasting().winnerUid;            let index = this.uids.indexOf(this.zuid);            this.quid = this.uids[(index + this.uids.length - 1) % this.uids.length];        } else {            this.quid = this.uids[parseInt(Math.random() * 100) % this.uids.length];        }        this.deal();    }    /**     * 发牌     */    deal() {        let pokers = algorithm.getPokers(this.model);        let length = this.model ? 16 : 15;        //pokers = [2, 15, 16, 28, 29, 41, 42, 4, 5, 6, 7, 8, 9, 10, 13, 23, 38, 11, 12, 24, 25, 37, 50, 51, 17, 18, 19, 20, 21, 22, 26, 30, 31, 32, 33, 34, 35, 36, 39, 40, 43, 44, 45, 46, 47, 48, 49, 3];        //pokers = [2, 3, 15, 16, 28, 29, 41, 42, 4, 5, 6, 7, 8, 9, 10, 13,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined,undefined];        //pokers = [2, 3, 15, 16, 28, 29, 41, 42, 4, 5, 6, 7, 8, 9, 10, 13];        if(this.renshu == 2){            if (this.model) {                this.allCard = pokers.slice(32);            }else{                this.allCard = pokers.slice(30);            }        }        this.players.forEach((player, i) => {            /**  条件：开启防作弊*/            player.holds = pokers.slice(i * length, i * length + length);            player.count();            //保存整手牌            this.holdsList[player.uid] = player.holds.slice(0);        }, this);    }    /**     * 开始游戏     */    begin() {        let wid = undefined;        let lastUids = this.getLasting().lastUids;        if (!!lastUids) {            let lastUidsStr = lastUids.sort().toString();            let curUids = this.uids.concat();            let curUidsStr = curUids.sort().toString();            if (lastUidsStr == curUidsStr) {                wid = this.getLasting().winnerUid; //上一局赢家            }        } else {            wid = this.getLasting().winnerUid; //上一局赢家        }        if (!!wid && this.uids.includes(wid)) {  //赢家先出            this.zuid = wid;            this.heitao3 = false;        } else {            if (this.firstBank || this.uids.length === 2) { //随机庄家                let index = Math.randomRange(0, this.uids.length);                this.zuid = this.uids[index];                this.heitao3 = false;            } else { //黑桃3先出                this.players.forEach((el) => {                    if (el.isHas) {                        this.zuid = el.uid;                    }                });                this.heitao3 = true;            }        }        this.turn = this.player(this.zuid).seatId;        this.sendAll("gameBegin", {            uids: this.uids,            zuid: this.zuid,            quid: this.quid,            isQie: this.isQie,            turnNum: this.turn        });        this.qiedengdaiTime = Date.now();        this.qiedengdai = this.setTimeout(() => {            this.startQie(40);        }, 3500);    }    /**     *  给前端发送切牌消息     */    startQie(index) {        if (this.isQie) {            return;        }        this.isQie = true;        this.clearTimeout(this.qiedengdai); //关闭等待定时器        console.log("切牌：",index);        this.sendAll('qieCard', {index: index});        this.setTimeout(() => { //等待切牌结束            this.startGame(); //开始游戏        }, 1500);    }    /**     * 通知前端开始游戏     */    startGame() {        //判断是否开启防作弊        if (this.antiCheating) {            this.players.forEach(player => {                player.isAntiCheating = false;            });            //发送发牌消息            this.sendAll('antiCheating');            //如果开启，只发送第一个出牌人的牌            let player = this.player(this.zuid);            player.sendHolds();            player.isAntiCheating = true;        } else {            this.players.forEach(player => {                player.sendHolds();            });        }        /**  2018.4.12 修改  每局游戏开始时给前端发送玩家手牌数 **/        if (this.numVisibles) {            let cardNum = {};            this.players.forEach((el) => {                cardNum[el.uid] = el.holds.length;            });            this.sendAll("localCardNum", cardNum);        }        //发送出牌玩家        this.changedTurn(this.uids[this.turn]);    }    /**     * 计算炸弹的分数     * @param index  打出炸弹的玩家下标     */    async calculateBombScore(index){        let bombPlayer = this.players[index];        let scoreObj = {};        let totalScore = 0;        this.players.forEach((player, id) => {            if(id === index){                return;            }            let score = 10 * this.ante;            if(this.zaniao && (player.isHearts10 || bombPlayer.isHearts10)){                // score *= 2;            }            totalScore += score;            scoreObj[player.uid] = score;            player.halfwayScore -= score;            bombPlayer.halfwayScore += score;        });        let winObj = {};        winObj[bombPlayer.uid] = totalScore;        //中途分数，在中途就要计算完成        let actual = await this.room.pushHalfwayScore(winObj, scoreObj);        //通知前端，炸弹计分        this.sendAll("bomb_score", actual);    }    /**     * 移到下一家出牌     */    nextTurn() {        console.log("turn: " + this.turn);        //判断玩家是否出玩        if (this.players[this.turn].holds.length === 0) {            return this.calculateResult(this.turn);        }        /** 轮转*/        this.turn = (++this.turn) % this.uids.length;        let player = this.players[this.turn];        let uid = this.uids[this.turn];        //判断玩家是否发过牌        if (this.antiCheating) {            if (!player.isAntiCheating) {                player.sendHolds();                player.isAntiCheating = true;            }        }        /**  2018.4.4 修改  保存打出的炸弹 **/        //如果上一手牌是自己打的，则清空        if (uid === this.currentPoker.uid) {            //如果炸弹都要不起，则算福利分            if (this.currentPoker.type === 4) {                 this.calculateBombScore(this.turn);            }            this.currentPoker = undefined;        } else {            //如果不是，则判断下家是否能要牌            let player = this.players[this.turn];            let func = ["", algorithm.findType1, algorithm.findType2, algorithm.findType3, algorithm.findType4, algorithm.findType5,                algorithm.findType6, algorithm.findType7, algorithm.findType8, algorithm.findType9];            if (this.currentPoker.type === 4) {                let res = algorithm.findType4(this.currentPoker, player.holds, player.counts);                if (!res) { //如果要不起，则一秒后提示                    this.setTimeout(function () {                        player.buyao();                    }, 1000);                }            } else {                let res = algorithm.findType4({val: 0}, player.holds, player.counts);                if (!res) {                    res = func[this.currentPoker.type](this.currentPoker, player.holds, player.counts);                }                /**  2018.6.1 添加接牌判断 **/                if (res && this.currentPoker.type === 3 && !this.sanzhangjiewan) {                    if (player.holds.length < 5) {                        res = false;                    }                }                if (res && this.currentPoker.type === 8 && !this.feijijiewan) {                    if (player.holds.length < this.currentPoker.length * 5) {                        res = false;                    }                }                if (!res) {                    console.log("要不起", player.uid);                    this.setTimeout(function () {                        player.buyao();                    }, 1000);                }            }        }        this.changedTurn(uid);    }    /**     * 修改出牌玩家     * @param uid     */    changedTurn(uid) {        console.log("进来出牌！");        this.startTimeout(uid);        this.sendAll("turn", {uid: uid});    }    /**     * 启动托管计时器     * @param uid     */    startTimeout (uid) {        this.clearTimeout(this.operatTimeoutId); //清空上一个计时器        this.operatTime = Date.now(); //操作开始时间        //倒计时id,如果在指定时间内没有出牌，则系统自动出牌        let player = this.player(uid);        if (!this.checkLastHolds(player)) {            let timeout = 30000;            //如果玩家已经托管，则只需等待1.5秒时间            console.log('player.isTrusteeship = ', player.isTrusteeship);            if (player.isTrusteeship) {                timeout = 1500;            }            this.operatTimeoutId = this.setTimeout(() => {                let player = this.player(uid);                let cards = [];                let lastIndex = (this.turn + 1) % this.uids.length;                let lastPlayer = this.player(this.uids[lastIndex]);                //如果打出的牌或者上一手牌是自己出的,或者第一手牌是自己出,则直接出手牌中最小的一个                if (this.foldsList.length === 0) {                    if (this.heitao3) {                        cards = (player.counts[3] === 4) ? [2, 15, 28, 41] : [41];                    } else {                        cards = player.getMinCards();                    }                } else {                    if (this.currentPoker === undefined) {                        cards = (lastPlayer.holds.length === 1) ? player.getMaxCards() : player.getMinCards();                    } else {                        if (lastPlayer.holds.length === 1 && this.currentPoker.type == 1) {                            //如果下家报单，则获取手牌中最大的单张或者炸弹                            cards = player.getMaxCards();                        } else {                            //上一手牌不是自己出的，则查找出能压上的牌型                            cards = player.getGreaterCards(this.currentPoker);                        }                    }                }                player.chupai(cards);                if (!player.isTrusteeship) {                    player.setTrusteeship(true);                    this.room.player(player.uid).isTrusteeship = true;                    this.sendAll(Event.tuoGuang, [player.uid, player.isTrusteeship]);                }            }, timeout);        }    }    checkLastHolds(player) {        let holds = player.holds.concat();        let alert = this.nextAlert();        let types = algorithm.findValues(holds, null, this.currentPoker, null, alert);        let res = algorithm.checkChupai(holds, types, holds, this.currentPoker, this.rule);        if (res.auto) {            setTimeout(function () {                if (player.holds.length > 0) {                    player.chupai(holds);                }            }, 1000);            return true;        }        return false;    }    /**     * 判断下家是否报警     * @return {boolean} true = 下家已经报警，反之未报警     */    nextAlert() {        let seatId = (this.turn + 1) % this.uids.length;        if (this.players[seatId].holds.length === 1) {            return true;        }    }    /**     * 计算结果     * @param winId 胜利的玩家的座位id     */    async calculateResult(winId) {        if (this._gameEnd) {            return;        }        this._gameEnd = true;        //计算玩家得分        this.calScore(winId);        //记录这一局赢家，方便下一局使用        this.getLasting().winnerUid = this.uids[winId];        this.getLasting().lastUids = this.uids.concat();        let loserCard = {}; //剩下的牌        this.players.forEach(el => {            if (el.holds.length > 0) {                loserCard[el.uid] = el.holds;            }        });        //上传分数        let actualScores = await this.pushScore();        if(this.renshu == 3){            this.allCard = undefined;        }        this.sendAll(Event.gameResult, {            allScore: actualScores,            loserCard: loserCard,            allCard:this.allCard        });        this.setTimeout(() => {            this.end();        }, 1000);    }    /**     * 计算结果得分     * @param winId     */    calScore(winId){        let winPlayer = this.players[winId];        let alertCount = 0;        this.players.forEach((player) => {            //赢家不计算            if(player.uid === winPlayer.uid) return;            //报单不计算            if(player.holds.length === 1) return ++alertCount;            //剩余牌            let cardsNumber = player.holds.length;            if(player.folds.length === 0){ //春天                cardsNumber = player.holds.length * 2;            } else if(this.smallTong && player.holds.length >= 10){ //小通                cardsNumber = this.model ? 16 : 15;            }            //判断是否扎鸟            cardsNumber *= (this.zaniao && (player.isHearts10 || winPlayer.isHearts10)) ? 2 : 1;            //计算分数            player.score -= cardsNumber * this.ante; //计算分数            winPlayer.score += Math.abs(player.score);        });        //双报        if(alertCount === 2 && this.doubleQuote){            this.players.forEach((player, i) => {                let score = 5;                if (i === winId) {                    player.score = score * 2 * this.ante;                } else {                    player.score = score * this.ante * (this.zaniao && (player.isHearts10 || winPlayer.isHearts10));                }            });        }    }    /**     * 回放数据     */    getPlayback() {        //历史记录        let history = {            zuid: this.zuid,            uids: this.uids,            bombCount: this.bombCount,            holdsList: [],            foldsList: [],            allScore: [],            lastHolds: [],            allCard:this.allCard        };        //计算分数        let allScore = {};        let loserCard = {}; //剩下的牌        this.players.forEach(el => {            allScore[el.uid] = el.score ;            if (el.holds.length > 0) {                loserCard[el.uid] = el.holds;            }        });        let index = 0;        this.foldsList.forEach((el) => {            index = this.uids.indexOf(parseInt(el.uid));            history.foldsList.push({index: index, cards: el.cards, type: el.type});        }, this);        for (let uid in this.holdsList) {            index = this.uids.indexOf(parseInt(uid));            history.holdsList[index] = this.holdsList[uid];        }        for (let uid in allScore) {            index = this.uids.indexOf(parseInt(uid));            history.allScore[index] = allScore[uid];        }        this.players.forEach((el) => {            history.lastHolds.push(el.holds);        });        return history;    }    /**     * 获取游戏信息     */    getInfo(uid) {        uid = parseInt(uid);        let msg = {            turn: this.players[this.turn].uid,     //谁出牌            uids: this.uids,                        //当前游戏中的玩家            players: {},            // sd: this.getLasting().getData(),            // isReEnter: true,            quid: this.quid,            isQie: this.isQie,            qiedengdaiTime: this.qiedengdaiTime,            currentPoker: this.currentPoker,            operatTime: this.operatTime,            model: this.model        };        this.players.forEach(function (el) {            if (uid === el.uid) {                msg.players[el.uid] = el.getInfos();            } else {                msg.players[el.uid] = el.getOtherInfos();            }        }, this);        this.send(uid, "gameInfo", msg);    }}module.exports = Main;